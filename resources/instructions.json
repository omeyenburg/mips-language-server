{
  "nop": [
    {
      "syntax": "nop",
      "description": "Null operation : machine code is all zeroes",
      "format": "R-format",
      "code": "000000 00000 00000 00000 00000 000000"
    }
  ],
  "add": [
    {
      "syntax": "add $t1,$t2,$t3",
      "description": "Addition with overflow : set $t1 to ($t2 plus $t3)",
      "format": "R-format",
      "code": "000000 sssss ttttt fffff 00000 100000"
    }
  ],
  "sub": [
    {
      "syntax": "sub $t1,$t2,$t3",
      "description": "Subtraction with overflow : set $t1 to ($t2 minus $t3)",
      "format": "R-format",
      "code": "000000 sssss ttttt fffff 00000 100010"
    }
  ],
  "addi": [
    {
      "syntax": "addi $t1,$t2,-100",
      "description": "Addition immediate with overflow : set $t1 to ($t2 plus signed 16-bit immediate)",
      "format": "I-format",
      "code": "001000 sssss fffff tttttttttttttttt"
    }
  ],
  "addu": [
    {
      "syntax": "addu $t1,$t2,$t3",
      "description": "Addition unsigned without overflow : set $t1 to ($t2 plus $t3), no overflow",
      "format": "R-format",
      "code": "000000 sssss ttttt fffff 00000 100001"
    }
  ],
  "subu": [
    {
      "syntax": "subu $t1,$t2,$t3",
      "description": "Subtraction unsigned without overflow : set $t1 to ($t2 minus $t3), no overflow",
      "format": "R-format",
      "code": "000000 sssss ttttt fffff 00000 100011"
    }
  ],
  "addiu": [
    {
      "syntax": "addiu $t1,$t2,-100",
      "description": "Addition immediate unsigned without overflow : set $t1 to ($t2 plus signed 16-bit immediate), no overflow",
      "format": "I-format",
      "code": "001001 sssss fffff tttttttttttttttt"
    }
  ],
  "mult": [
    {
      "syntax": "mult $t1,$t2",
      "description": "Multiplication : Set hi to high-order 32 bits, lo to low-order 32 bits of the product of $t1 and $t2 (use mfhi to access hi, mflo to access lo)",
      "format": "R-format",
      "code": "000000 fffff sssss 00000 00000 011000"
    }
  ],
  "multu": [
    {
      "syntax": "multu $t1,$t2",
      "description": "Multiplication unsigned : Set HI to high-order 32 bits, LO to low-order 32 bits of the product of unsigned $t1 and $t2 (use mfhi to access HI, mflo to access LO)",
      "format": "R-format",
      "code": "000000 fffff sssss 00000 00000 011001"
    }
  ],
  "mul": [
    {
      "syntax": "mul $t1,$t2,$t3",
      "description": "Multiplication without overflow  : Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of the product of $t2 and $t3 (use mfhi to access HI, mflo to access LO)",
      "format": "R-format",
      "code": "011100 sssss ttttt fffff 00000 000010"
    }
  ],
  "madd": [
    {
      "syntax": "madd $t1,$t2",
      "description": "Multiply add : Multiply $t1 by $t2 then increment HI by high-order 32 bits of product, increment LO by low-order 32 bits of product (use mfhi to access HI, mflo to access LO)",
      "format": "R-format",
      "code": "011100 fffff sssss 00000 00000 000000"
    }
  ],
  "maddu": [
    {
      "syntax": "maddu $t1,$t2",
      "description": "Multiply add unsigned : Multiply $t1 by $t2 then increment HI by high-order 32 bits of product, increment LO by low-order 32 bits of product, unsigned (use mfhi to access HI, mflo to access LO)",
      "format": "R-format",
      "code": "011100 fffff sssss 00000 00000 000001"
    }
  ],
  "msub": [
    {
      "syntax": "msub $t1,$t2",
      "description": "Multiply subtract : Multiply $t1 by $t2 then decrement HI by high-order 32 bits of product, decrement LO by low-order 32 bits of product (use mfhi to access HI, mflo to access LO)",
      "format": "R-format",
      "code": "011100 fffff sssss 00000 00000 000100"
    }
  ],
  "msubu": [
    {
      "syntax": "msubu $t1,$t2",
      "description": "Multiply subtract unsigned : Multiply $t1 by $t2 then decrement HI by high-order 32 bits of product, decement LO by low-order 32 bits of product, unsigned (use mfhi to access HI, mflo to access LO)",
      "format": "R-format",
      "code": "011100 fffff sssss 00000 00000 000101"
    }
  ],
  "div": [
    {
      "syntax": "div $t1,$t2",
      "description": "Division with overflow : Divide $t1 by $t2 then set LO to quotient and HI to remainder (use mfhi to access HI, mflo to access LO)",
      "format": "R-format",
      "code": "000000 fffff sssss 00000 00000 011010"
    }
  ],
  "divu": [
    {
      "syntax": "divu $t1,$t2",
      "description": "Division unsigned without overflow : Divide unsigned $t1 by $t2 then set LO to quotient and HI to remainder (use mfhi to access HI, mflo to access LO)",
      "format": "R-format",
      "code": "000000 fffff sssss 00000 00000 011011"
    }
  ],
  "mfhi": [
    {
      "syntax": "mfhi $t1",
      "description": "Move from HI register : Set $t1 to contents of HI (see multiply and divide operations)",
      "format": "R-format",
      "code": "000000 00000 00000 fffff 00000 010000"
    }
  ],
  "mflo": [
    {
      "syntax": "mflo $t1",
      "description": "Move from LO register : Set $t1 to contents of LO (see multiply and divide operations)",
      "format": "R-format",
      "code": "000000 00000 00000 fffff 00000 010010"
    }
  ],
  "mthi": [
    {
      "syntax": "mthi $t1",
      "description": "Move to HI registerr : Set HI to contents of $t1 (see multiply and divide operations)",
      "format": "R-format",
      "code": "000000 fffff 00000 00000 00000 010001"
    }
  ],
  "mtlo": [
    {
      "syntax": "mtlo $t1",
      "description": "Move to LO register : Set LO to contents of $t1 (see multiply and divide operations)",
      "format": "R-format",
      "code": "000000 fffff 00000 00000 00000 010011"
    }
  ],
  "and": [
    {
      "syntax": "and $t1,$t2,$t3",
      "description": "Bitwise AND : Set $t1 to bitwise AND of $t2 and $t3",
      "format": "R-format",
      "code": "000000 sssss ttttt fffff 00000 100100"
    }
  ],
  "or": [
    {
      "syntax": "or $t1,$t2,$t3",
      "description": "Bitwise OR : Set $t1 to bitwise OR of $t2 and $t3",
      "format": "R-format",
      "code": "000000 sssss ttttt fffff 00000 100101"
    }
  ],
  "andi": [
    {
      "syntax": "andi $t1,$t2,100",
      "description": "Bitwise AND immediate : Set $t1 to bitwise AND of $t2 and zero-extended 16-bit immediate",
      "format": "I-format",
      "code": "001100 sssss fffff tttttttttttttttt"
    }
  ],
  "ori": [
    {
      "syntax": "ori $t1,$t2,100",
      "description": "Bitwise OR immediate : Set $t1 to bitwise OR of $t2 and zero-extended 16-bit immediate",
      "format": "I-format",
      "code": "001101 sssss fffff tttttttttttttttt"
    }
  ],
  "nor": [
    {
      "syntax": "nor $t1,$t2,$t3",
      "description": "Bitwise NOR : Set $t1 to bitwise NOR of $t2 and $t3",
      "format": "R-format",
      "code": "000000 sssss ttttt fffff 00000 100111"
    }
  ],
  "xor": [
    {
      "syntax": "xor $t1,$t2,$t3",
      "description": "Bitwise XOR (exclusive OR) : Set $t1 to bitwise XOR of $t2 and $t3",
      "format": "R-format",
      "code": "000000 sssss ttttt fffff 00000 100110"
    }
  ],
  "xori": [
    {
      "syntax": "xori $t1,$t2,100",
      "description": "Bitwise XOR immediate : Set $t1 to bitwise XOR of $t2 and zero-extended 16-bit immediate",
      "format": "I-format",
      "code": "001110 sssss fffff tttttttttttttttt"
    }
  ],
  "sll": [
    {
      "syntax": "sll $t1,$t2,10",
      "description": "Shift left logical : Set $t1 to result of shifting $t2 left by number of bits specified by immediate",
      "format": "R-format",
      "code": "000000 00000 sssss fffff ttttt 000000"
    }
  ],
  "sllv": [
    {
      "syntax": "sllv $t1,$t2,$t3",
      "description": "Shift left logical variable : Set $t1 to result of shifting $t2 left by number of bits specified by value in low-order 5 bits of $t3",
      "format": "R-format",
      "code": "000000 ttttt sssss fffff 00000 000100"
    }
  ],
  "srl": [
    {
      "syntax": "srl $t1,$t2,10",
      "description": "Shift right logical : Set $t1 to result of shifting $t2 right by number of bits specified by immediate",
      "format": "R-format",
      "code": "000000 00000 sssss fffff ttttt 000010"
    }
  ],
  "sra": [
    {
      "syntax": "sra $t1,$t2,10",
      "description": "Shift right arithmetic : Set $t1 to result of sign-extended shifting $t2 right by number of bits specified by immediate",
      "format": "R-format",
      "code": "000000 00000 sssss fffff ttttt 000011"
    }
  ],
  "srav": [
    {
      "syntax": "srav $t1,$t2,$t3",
      "description": "Shift right arithmetic variable : Set $t1 to result of sign-extended shifting $t2 right by number of bits specified by value in low-order 5 bits of $t3",
      "format": "R-format",
      "code": "000000 ttttt sssss fffff 00000 000111"
    }
  ],
  "srlv": [
    {
      "syntax": "srlv $t1,$t2,$t3",
      "description": "Shift right logical variable : Set $t1 to result of shifting $t2 right by number of bits specified by value in low-order 5 bits of $t3",
      "format": "R-format",
      "code": "000000 ttttt sssss fffff 00000 000110"
    }
  ],
  "lw": [
    {
      "syntax": "lw $t1,-100($t2)",
      "description": "Load word : Set $t1 to contents of effective memory word address",
      "format": "I-format",
      "code": "100011 ttttt fffff ssssssssssssssss"
    }
  ],
  "ll": [
    {
      "syntax": "ll $t1,-100($t2)",
      "description": "Load linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.",
      "format": "I-format",
      "code": "110000 ttttt fffff ssssssssssssssss"
    }
  ],
  "lwl": [
    {
      "syntax": "lwl $t1,-100($t2)",
      "description": "Load word left : Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word",
      "format": "I-format",
      "code": "100010 ttttt fffff ssssssssssssssss"
    }
  ],
  "lwr": [
    {
      "syntax": "lwr $t1,-100($t2)",
      "description": "Load word right : Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word",
      "format": "I-format",
      "code": "100110 ttttt fffff ssssssssssssssss"
    }
  ],
  "sw": [
    {
      "syntax": "sw $t1,-100($t2)",
      "description": "Store word : Store contents of $t1 into effective memory word address",
      "format": "I-format",
      "code": "101011 ttttt fffff ssssssssssssssss"
    }
  ],
  "sc": [
    {
      "syntax": "sc $t1,-100($t2)",
      "description": "Store conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Stores $t1 value into effective address, then sets $t1 to 1 for success.  Always succeeds because MARS does not simulate multiple processors.",
      "format": "I-format",
      "code": "111000 ttttt fffff ssssssssssssssss"
    }
  ],
  "swl": [
    {
      "syntax": "swl $t1,-100($t2)",
      "description": "Store word left : Store high-order 1 to 4 bytes of $t1 into memory, starting with effective byte address and continuing through the low-order byte of its word",
      "format": "I-format",
      "code": "101010 ttttt fffff ssssssssssssssss"
    }
  ],
  "swr": [
    {
      "syntax": "swr $t1,-100($t2)",
      "description": "Store word right : Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective byte address and continuing through that byte address",
      "format": "I-format",
      "code": "101110 ttttt fffff ssssssssssssssss"
    }
  ],
  "lui": [
    {
      "syntax": "lui $t1,100",
      "description": "Load upper immediate : Set high-order 16 bits of $t1 to 16-bit immediate and low-order 16 bits to 0",
      "format": "I-format",
      "code": "001111 00000 fffff ssssssssssssssss"
    }
  ],
  "beq": [
    {
      "syntax": "beq $t1,$t2,label",
      "description": "Branch if equal : Branch to statement at label's address if $t1 and $t2 are equal",
      "format": "I_BRANCH-format",
      "code": "000100 fffff sssss tttttttttttttttt"
    }
  ],
  "bne": [
    {
      "syntax": "bne $t1,$t2,label",
      "description": "Branch if not equal : Branch to statement at label's address if $t1 and $t2 are not equal",
      "format": "I_BRANCH-format",
      "code": "000101 fffff sssss tttttttttttttttt"
    }
  ],
  "bgez": [
    {
      "syntax": "bgez $t1,label",
      "description": "Branch if greater than or equal to zero : Branch to statement at label's address if $t1 is greater than or equal to zero",
      "format": "I_BRANCH-format",
      "code": "000001 fffff 00001 ssssssssssssssss"
    }
  ],
  "bgezal": [
    {
      "syntax": "bgezal $t1,label",
      "description": "Branch if greater then or equal to zero and link : If $t1 is greater than or equal to zero, then set $ra to the Program Counter and branch to statement at label's address",
      "format": "I_BRANCH-format",
      "code": "000001 fffff 10001 ssssssssssssssss"
    }
  ],
  "bgtz": [
    {
      "syntax": "bgtz $t1,label",
      "description": "Branch if greater than zero : Branch to statement at label's address if $t1 is greater than zero",
      "format": "I_BRANCH-format",
      "code": "000111 fffff 00000 ssssssssssssssss"
    }
  ],
  "blez": [
    {
      "syntax": "blez $t1,label",
      "description": "Branch if less than or equal to zero : Branch to statement at label's address if $t1 is less than or equal to zero",
      "format": "I_BRANCH-format",
      "code": "000110 fffff 00000 ssssssssssssssss"
    }
  ],
  "bltz": [
    {
      "syntax": "bltz $t1,label",
      "description": "Branch if less than zero : Branch to statement at label's address if $t1 is less than zero",
      "format": "I_BRANCH-format",
      "code": "000001 fffff 00000 ssssssssssssssss"
    }
  ],
  "bltzal": [
    {
      "syntax": "bltzal $t1,label",
      "description": "Branch if less than zero and link : If $t1 is less than or equal to zero, then set $ra to the Program Counter and branch to statement at label's address",
      "format": "I_BRANCH-format",
      "code": "000001 fffff 10000 ssssssssssssssss"
    }
  ],
  "slt": [
    {
      "syntax": "slt $t1,$t2,$t3",
      "description": "Set less than : If $t2 is less than $t3, then set $t1 to 1 else set $t1 to 0",
      "format": "R-format",
      "code": "000000 sssss ttttt fffff 00000 101010"
    }
  ],
  "sltu": [
    {
      "syntax": "sltu $t1,$t2,$t3",
      "description": "Set less than unsigned : If $t2 is less than $t3 using unsigned comparision, then set $t1 to 1 else set $t1 to 0",
      "format": "R-format",
      "code": "000000 sssss ttttt fffff 00000 101011"
    }
  ],
  "slti": [
    {
      "syntax": "slti $t1,$t2,-100",
      "description": "Set less than immediate : If $t2 is less than sign-extended 16-bit immediate, then set $t1 to 1 else set $t1 to 0",
      "format": "I-format",
      "code": "001010 sssss fffff tttttttttttttttt"
    }
  ],
  "sltiu": [
    {
      "syntax": "sltiu $t1,$t2,-100",
      "description": "Set less than immediate unsigned : If $t2 is less than  sign-extended 16-bit immediate using unsigned comparison, then set $t1 to 1 else set $t1 to 0",
      "format": "I-format",
      "code": "001011 sssss fffff tttttttttttttttt"
    }
  ],
  "movn": [
    {
      "syntax": "movn $t1,$t2,$t3",
      "description": "Move conditional not zero : Set $t1 to $t2 if $t3 is not zero",
      "format": "R-format",
      "code": "000000 sssss ttttt fffff 00000 001011"
    }
  ],
  "movz": [
    {
      "syntax": "movz $t1,$t2,$t3",
      "description": "Move conditional zero : Set $t1 to $t2 if $t3 is zero",
      "format": "R-format",
      "code": "000000 sssss ttttt fffff 00000 001010"
    }
  ],
  "movf": [
    {
      "syntax": "movf $t1,$t2",
      "description": "Move if FP condition flag 0 false : Set $t1 to $t2 if FPU (Coprocessor 1) condition flag 0 is false (zero)",
      "format": "R-format",
      "code": "000000 sssss 000 00 fffff 00000 000001"
    },
    {
      "syntax": "movf $t1,$t2,1",
      "description": "Move if specified FP condition flag false : Set $t1 to $t2 if FPU (Coprocessor 1) condition flag specified by the immediate is false (zero)",
      "format": "R-format",
      "code": "000000 sssss ttt 00 fffff 00000 000001"
    }
  ],
  "movt": [
    {
      "syntax": "movt $t1,$t2",
      "description": "Move if FP condition flag 0 true : Set $t1 to $t2 if FPU (Coprocessor 1) condition flag 0 is true (one)",
      "format": "R-format",
      "code": "000000 sssss 000 01 fffff 00000 000001"
    },
    {
      "syntax": "movt $t1,$t2,1",
      "description": "Move if specfied FP condition flag true : Set $t1 to $t2 if FPU (Coprocessor 1) condition flag specified by the immediate is true (one)",
      "format": "R-format",
      "code": "000000 sssss ttt 01 fffff 00000 000001"
    }
  ],
  "break": [
    {
      "syntax": "break 100",
      "description": "Break execution with code : Terminate program execution with specified exception code",
      "format": "R-format",
      "code": "000000 ffffffffffffffffffff 001101"
    },
    {
      "syntax": "break",
      "description": "Break execution : Terminate program execution with exception",
      "format": "R-format",
      "code": "000000 00000 00000 00000 00000 001101"
    }
  ],
  "syscall": [
    {
      "syntax": "syscall",
      "description": "Issue a system call : Execute the system call specified by value in $v0",
      "format": "R-format",
      "code": "000000 00000 00000 00000 00000 001100"
    }
  ],
  "j": [
    {
      "syntax": "j target",
      "description": "Jump unconditionally : Jump to statement at target address",
      "format": "J-format",
      "code": "000010 ffffffffffffffffffffffffff"
    }
  ],
  "jr": [
    {
      "syntax": "jr $t1",
      "description": "Jump register unconditionally : Jump to statement whose address is in $t1",
      "format": "R-format",
      "code": "000000 fffff 00000 00000 00000 001000"
    }
  ],
  "jal": [
    {
      "syntax": "jal target",
      "description": "Jump and link : Set $ra to Program Counter (return address) then jump to statement at target address",
      "format": "J-format",
      "code": "000011 ffffffffffffffffffffffffff"
    }
  ],
  "jalr": [
    {
      "syntax": "jalr $t1,$t2",
      "description": "Jump and link register : Set $t1 to Program Counter (return address) then jump to statement whose address is in $t2",
      "format": "R-format",
      "code": "000000 sssss 00000 fffff 00000 001001"
    },
    {
      "syntax": "jalr $t1",
      "description": "Jump and link register : Set $ra to Program Counter (return address) then jump to statement whose address is in $t1",
      "format": "R-format",
      "code": "000000 fffff 00000 11111 00000 001001"
    }
  ],
  "lb": [
    {
      "syntax": "lb $t1,-100($t2)",
      "description": "Load byte : Set $t1 to sign-extended 8-bit value from effective memory byte address",
      "format": "I-format",
      "code": "100000 ttttt fffff ssssssssssssssss"
    }
  ],
  "lh": [
    {
      "syntax": "lh $t1,-100($t2)",
      "description": "Load halfword : Set $t1 to sign-extended 16-bit value from effective memory halfword address",
      "format": "I-format",
      "code": "100001 ttttt fffff ssssssssssssssss"
    }
  ],
  "lhu": [
    {
      "syntax": "lhu $t1,-100($t2)",
      "description": "Load halfword unsigned : Set $t1 to zero-extended 16-bit value from effective memory halfword address",
      "format": "I-format",
      "code": "100101 ttttt fffff ssssssssssssssss"
    }
  ],
  "lbu": [
    {
      "syntax": "lbu $t1,-100($t2)",
      "description": "Load byte unsigned : Set $t1 to zero-extended 8-bit value from effective memory byte address",
      "format": "I-format",
      "code": "100100 ttttt fffff ssssssssssssssss"
    }
  ],
  "sb": [
    {
      "syntax": "sb $t1,-100($t2)",
      "description": "Store byte : Store the low-order 8 bits of $t1 into the effective memory byte address",
      "format": "I-format",
      "code": "101000 ttttt fffff ssssssssssssssss"
    }
  ],
  "sh": [
    {
      "syntax": "sh $t1,-100($t2)",
      "description": "Store halfword : Store the low-order 16 bits of $t1 into the effective memory halfword address",
      "format": "I-format",
      "code": "101001 ttttt fffff ssssssssssssssss"
    }
  ],
  "mfc0": [
    {
      "syntax": "mfc0 $t1,$8",
      "description": "Move from Coprocessor 0 : Set $t1 to the value stored in Coprocessor 0 register $8",
      "format": "R-format",
      "code": "010000 00000 fffff sssss 00000 000000"
    }
  ],
  "mtc0": [
    {
      "syntax": "mtc0 $t1,$8",
      "description": "Move to Coprocessor 0 : Set Coprocessor 0 register $8 to value stored in $t1",
      "format": "R-format",
      "code": "010000 00100 fffff sssss 00000 000000"
    }
  ],
  "add.s": [
    {
      "syntax": "add.s $f0,$f1,$f3",
      "description": "Floating point addition single precision : Set $f0 to single-precision floating point value of $f1 plus $f3",
      "format": "R-format",
      "code": "010001 10000 ttttt sssss fffff 000000"
    }
  ],
  "sub.s": [
    {
      "syntax": "sub.s $f0,$f1,$f3",
      "description": "Floating point subtraction single precision : Set $f0 to single-precision floating point value of $f1  minus $f3",
      "format": "R-format",
      "code": "010001 10000 ttttt sssss fffff 000001"
    }
  ],
  "mul.s": [
    {
      "syntax": "mul.s $f0,$f1,$f3",
      "description": "Floating point multiplication single precision : Set $f0 to single-precision floating point value of $f1 times $f3",
      "format": "R-format",
      "code": "010001 10000 ttttt sssss fffff 000010"
    }
  ],
  "div.s": [
    {
      "syntax": "div.s $f0,$f1,$f3",
      "description": "Floating point division single precision : Set $f0 to single-precision floating point value of $f1 divided by $f3",
      "format": "R-format",
      "code": "010001 10000 ttttt sssss fffff 000011"
    }
  ],
  "sqrt.s": [
    {
      "syntax": "sqrt.s $f0,$f1",
      "description": "Square root single precision : Set $f0 to single-precision floating point square root of $f1",
      "format": "R-format",
      "code": "010001 10000 00000 sssss fffff 000100"
    }
  ],
  "floor.w.s": [
    {
      "syntax": "floor.w.s $f0,$f1",
      "description": "Floor single precision to word : Set $f0 to 32-bit integer floor of single-precision float in $f1",
      "format": "R-format",
      "code": "010001 10000 00000 sssss fffff 001111"
    }
  ],
  "ceil.w.s": [
    {
      "syntax": "ceil.w.s $f0,$f1",
      "description": "Ceiling single precision to word : Set $f0 to 32-bit integer ceiling of single-precision float in $f1",
      "format": "R-format",
      "code": "010001 10000 00000 sssss fffff 001110"
    }
  ],
  "round.w.s": [
    {
      "syntax": "round.w.s $f0,$f1",
      "description": "Round single precision to word : Set $f0 to 32-bit integer round of single-precision float in $f1",
      "format": "R-format",
      "code": "010001 10000 00000 sssss fffff 001100"
    }
  ],
  "trunc.w.s": [
    {
      "syntax": "trunc.w.s $f0,$f1",
      "description": "Truncate single precision to word : Set $f0 to 32-bit integer truncation of single-precision float in $f1",
      "format": "R-format",
      "code": "010001 10000 00000 sssss fffff 001101"
    }
  ],
  "add.d": [
    {
      "syntax": "add.d $f2,$f4,$f6",
      "description": "Floating point addition double precision : Set $f2 to double-precision floating point value of $f4 plus $f6",
      "format": "R-format",
      "code": "010001 10001 ttttt sssss fffff 000000"
    }
  ],
  "sub.d": [
    {
      "syntax": "sub.d $f2,$f4,$f6",
      "description": "Floating point subtraction double precision : Set $f2 to double-precision floating point value of $f4 minus $f6",
      "format": "R-format",
      "code": "010001 10001 ttttt sssss fffff 000001"
    }
  ],
  "mul.d": [
    {
      "syntax": "mul.d $f2,$f4,$f6",
      "description": "Floating point multiplication double precision : Set $f2 to double-precision floating point value of $f4 times $f6",
      "format": "R-format",
      "code": "010001 10001 ttttt sssss fffff 000010"
    }
  ],
  "div.d": [
    {
      "syntax": "div.d $f2,$f4,$f6",
      "description": "Floating point division double precision : Set $f2 to double-precision floating point value of $f4 divided by $f6",
      "format": "R-format",
      "code": "010001 10001 ttttt sssss fffff 000011"
    }
  ],
  "sqrt.d": [
    {
      "syntax": "sqrt.d $f2,$f4",
      "description": "Square root double precision : Set $f2 to double-precision floating point square root of $f4",
      "format": "R-format",
      "code": "010001 10001 00000 sssss fffff 000100"
    }
  ],
  "floor.w.d": [
    {
      "syntax": "floor.w.d $f1,$f2",
      "description": "Floor double precision to word : Set $f1 to 32-bit integer floor of double-precision float in $f2",
      "format": "R-format",
      "code": "010001 10001 00000 sssss fffff 001111"
    }
  ],
  "ceil.w.d": [
    {
      "syntax": "ceil.w.d $f1,$f2",
      "description": "Ceiling double precision to word : Set $f1 to 32-bit integer ceiling of double-precision float in $f2",
      "format": "R-format",
      "code": "010001 10001 00000 sssss fffff 001110"
    }
  ],
  "round.w.d": [
    {
      "syntax": "round.w.d $f1,$f2",
      "description": "Round double precision to word : Set $f1 to 32-bit integer round of double-precision float in $f2",
      "format": "R-format",
      "code": "010001 10001 00000 sssss fffff 001100"
    }
  ],
  "trunc.w.d": [
    {
      "syntax": "trunc.w.d $f1,$f2",
      "description": "Truncate double precision to word : Set $f1 to 32-bit integer truncation of double-precision float in $f2",
      "format": "R-format",
      "code": "010001 10001 00000 sssss fffff 001101"
    }
  ],
  "bc1t": [
    {
      "syntax": "bc1t label",
      "description": "Branch if FP condition flag 0 true (BC1T, not BCLT) : If Coprocessor 1 condition flag 0 is true (one) then branch to statement at label's address",
      "format": "I_BRANCH-format",
      "code": "010001 01000 00001 ffffffffffffffff"
    },
    {
      "syntax": "bc1t 1,label",
      "description": "Branch if specified FP condition flag true (BC1T, not BCLT) : If Coprocessor 1 condition flag specified by immediate is true (one) then branch to statement at label's address",
      "format": "I_BRANCH-format",
      "code": "010001 01000 fff 01 ssssssssssssssss"
    }
  ],
  "bc1f": [
    {
      "syntax": "bc1f label",
      "description": "Branch if FP condition flag 0 false (BC1F, not BCLF) : If Coprocessor 1 condition flag 0 is false (zero) then branch to statement at label's address",
      "format": "I_BRANCH-format",
      "code": "010001 01000 00000 ffffffffffffffff"
    },
    {
      "syntax": "bc1f 1,label",
      "description": "Branch if specified FP condition flag false (BC1F, not BCLF) : If Coprocessor 1 condition flag specified by immediate is false (zero) then branch to statement at label's address",
      "format": "I_BRANCH-format",
      "code": "010001 01000 fff 00 ssssssssssssssss"
    }
  ],
  "c.eq.s": [
    {
      "syntax": "c.eq.s $f0,$f1",
      "description": "Compare equal single precision : If $f0 is equal to $f1, set Coprocessor 1 condition flag 0 true else set it false",
      "format": "R-format",
      "code": "010001 10000 sssss fffff 00000 110010"
    },
    {
      "syntax": "c.eq.s 1,$f0,$f1",
      "description": "Compare equal single precision : If $f0 is equal to $f1, set Coprocessor 1 condition flag specied by immediate to true else set it to false",
      "format": "R-format",
      "code": "010001 10000 ttttt sssss fff 00 11 0010"
    }
  ],
  "c.le.s": [
    {
      "syntax": "c.le.s $f0,$f1",
      "description": "Compare less or equal single precision : If $f0 is less than or equal to $f1, set Coprocessor 1 condition flag 0 true else set it false",
      "format": "R-format",
      "code": "010001 10000 sssss fffff 00000 111110"
    },
    {
      "syntax": "c.le.s 1,$f0,$f1",
      "description": "Compare less or equal single precision : If $f0 is less than or equal to $f1, set Coprocessor 1 condition flag specified by immediate to true else set it to false",
      "format": "R-format",
      "code": "010001 10000 ttttt sssss fff 00 111110"
    }
  ],
  "c.lt.s": [
    {
      "syntax": "c.lt.s $f0,$f1",
      "description": "Compare less than single precision : If $f0 is less than $f1, set Coprocessor 1 condition flag 0 true else set it false",
      "format": "R-format",
      "code": "010001 10000 sssss fffff 00000 111100"
    },
    {
      "syntax": "c.lt.s 1,$f0,$f1",
      "description": "Compare less than single precision : If $f0 is less than $f1, set Coprocessor 1 condition flag specified by immediate to true else set it to false",
      "format": "R-format",
      "code": "010001 10000 ttttt sssss fff 00 111100"
    }
  ],
  "c.eq.d": [
    {
      "syntax": "c.eq.d $f2,$f4",
      "description": "Compare equal double precision : If $f2 is equal to $f4 (double-precision), set Coprocessor 1 condition flag 0 true else set it false",
      "format": "R-format",
      "code": "010001 10001 sssss fffff 00000 110010"
    },
    {
      "syntax": "c.eq.d 1,$f2,$f4",
      "description": "Compare equal double precision : If $f2 is equal to $f4 (double-precision), set Coprocessor 1 condition flag specified by immediate to true else set it to false",
      "format": "R-format",
      "code": "010001 10001 ttttt sssss fff 00 110010"
    }
  ],
  "c.le.d": [
    {
      "syntax": "c.le.d $f2,$f4",
      "description": "Compare less or equal double precision : If $f2 is less than or equal to $f4 (double-precision), set Coprocessor 1 condition flag 0 true else set it false",
      "format": "R-format",
      "code": "010001 10001 sssss fffff 00000 111110"
    },
    {
      "syntax": "c.le.d 1,$f2,$f4",
      "description": "Compare less or equal double precision : If $f2 is less than or equal to $f4 (double-precision), set Coprocessor 1 condition flag specfied by immediate true else set it false",
      "format": "R-format",
      "code": "010001 10001 ttttt sssss fff 00 111110"
    }
  ],
  "c.lt.d": [
    {
      "syntax": "c.lt.d $f2,$f4",
      "description": "Compare less than double precision : If $f2 is less than $f4 (double-precision), set Coprocessor 1 condition flag 0 true else set it false",
      "format": "R-format",
      "code": "010001 10001 sssss fffff 00000 111100"
    },
    {
      "syntax": "c.lt.d 1,$f2,$f4",
      "description": "Compare less than double precision : If $f2 is less than $f4 (double-precision), set Coprocessor 1 condition flag specified by immediate to true else set it to false",
      "format": "R-format",
      "code": "010001 10001 ttttt sssss fff 00 111100"
    }
  ],
  "abs.s": [
    {
      "syntax": "abs.s $f0,$f1",
      "description": "Floating point absolute value single precision : Set $f0 to absolute value of $f1, single precision",
      "format": "R-format",
      "code": "010001 10000 00000 sssss fffff 000101"
    }
  ],
  "abs.d": [
    {
      "syntax": "abs.d $f2,$f4",
      "description": "Floating point absolute value double precision : Set $f2 to absolute value of $f4, double precision",
      "format": "R-format",
      "code": "010001 10001 00000 sssss fffff 000101"
    }
  ],
  "cvt.d.s": [
    {
      "syntax": "cvt.d.s $f2,$f1",
      "description": "Convert from single precision to double precision : Set $f2 to double precision equivalent of single precision value in $f1",
      "format": "R-format",
      "code": "010001 10000 00000 sssss fffff 100001"
    }
  ],
  "cvt.d.w": [
    {
      "syntax": "cvt.d.w $f2,$f1",
      "description": "Convert from word to double precision : Set $f2 to double precision equivalent of 32-bit integer value in $f1",
      "format": "R-format",
      "code": "010001 10100 00000 sssss fffff 100001"
    }
  ],
  "cvt.s.d": [
    {
      "syntax": "cvt.s.d $f1,$f2",
      "description": "Convert from double precision to single precision : Set $f1 to single precision equivalent of double precision value in $f2",
      "format": "R-format",
      "code": "010001 10001 00000 sssss fffff 100000"
    }
  ],
  "cvt.s.w": [
    {
      "syntax": "cvt.s.w $f0,$f1",
      "description": "Convert from word to single precision : Set $f0 to single precision equivalent of 32-bit integer value in $f2",
      "format": "R-format",
      "code": "010001 10100 00000 sssss fffff 100000"
    }
  ],
  "cvt.w.d": [
    {
      "syntax": "cvt.w.d $f1,$f2",
      "description": "Convert from double precision to word : Set $f1 to 32-bit integer equivalent of double precision value in $f2",
      "format": "R-format",
      "code": "010001 10001 00000 sssss fffff 100100"
    }
  ],
  "cvt.w.s": [
    {
      "syntax": "cvt.w.s $f0,$f1",
      "description": "Convert from single precision to word : Set $f0 to 32-bit integer equivalent of single precision value in $f1",
      "format": "R-format",
      "code": "010001 10000 00000 sssss fffff 100100"
    }
  ],
  "mov.d": [
    {
      "syntax": "mov.d $f2,$f4",
      "description": "Move floating point double precision : Set double precision $f2 to double precision value in $f4",
      "format": "R-format",
      "code": "010001 10001 00000 sssss fffff 000110"
    }
  ],
  "movf.d": [
    {
      "syntax": "movf.d $f2,$f4",
      "description": "Move floating point double precision : If condition flag 0 false, set double precision $f2 to double precision value in $f4",
      "format": "R-format",
      "code": "010001 10001 000 00 sssss fffff 010001"
    },
    {
      "syntax": "movf.d $f2,$f4,1",
      "description": "Move floating point double precision : If condition flag specified by immediate is false, set double precision $f2 to double precision value in $f4",
      "format": "R-format",
      "code": "010001 10001 ttt 00 sssss fffff 010001"
    }
  ],
  "movt.d": [
    {
      "syntax": "movt.d $f2,$f4",
      "description": "Move floating point double precision : If condition flag 0 true, set double precision $f2 to double precision value in $f4",
      "format": "R-format",
      "code": "010001 10001 000 01 sssss fffff 010001"
    },
    {
      "syntax": "movt.d $f2,$f4,1",
      "description": "Move floating point double precision : If condition flag specified by immediate is true, set double precision $f2 to double precision value in $f4e",
      "format": "R-format",
      "code": "010001 10001 ttt 01 sssss fffff 010001"
    }
  ],
  "movn.d": [
    {
      "syntax": "movn.d $f2,$f4,$t3",
      "description": "Move floating point double precision : If $t3 is not zero, set double precision $f2 to double precision value in $f4",
      "format": "R-format",
      "code": "010001 10001 ttttt sssss fffff 010011"
    }
  ],
  "movz.d": [
    {
      "syntax": "movz.d $f2,$f4,$t3",
      "description": "Move floating point double precision : If $t3 is zero, set double precision $f2 to double precision value in $f4",
      "format": "R-format",
      "code": "010001 10001 ttttt sssss fffff 010010"
    }
  ],
  "mov.s": [
    {
      "syntax": "mov.s $f0,$f1",
      "description": "Move floating point single precision : Set single precision $f0 to single precision value in $f1",
      "format": "R-format",
      "code": "010001 10000 00000 sssss fffff 000110"
    }
  ],
  "movf.s": [
    {
      "syntax": "movf.s $f0,$f1",
      "description": "Move floating point single precision : If condition flag 0 is false, set single precision $f0 to single precision value in $f1",
      "format": "R-format",
      "code": "010001 10000 000 00 sssss fffff 010001"
    },
    {
      "syntax": "movf.s $f0,$f1,1",
      "description": "Move floating point single precision : If condition flag specified by immediate is false, set single precision $f0 to single precision value in $f1e",
      "format": "R-format",
      "code": "010001 10000 ttt 00 sssss fffff 010001"
    }
  ],
  "movt.s": [
    {
      "syntax": "movt.s $f0,$f1",
      "description": "Move floating point single precision : If condition flag 0 is true, set single precision $f0 to single precision value in $f1e",
      "format": "R-format",
      "code": "010001 10000 000 01 sssss fffff 010001"
    },
    {
      "syntax": "movt.s $f0,$f1,1",
      "description": "Move floating point single precision : If condition flag specified by immediate is true, set single precision $f0 to single precision value in $f1e",
      "format": "R-format",
      "code": "010001 10000 ttt 01 sssss fffff 010001"
    }
  ],
  "movn.s": [
    {
      "syntax": "movn.s $f0,$f1,$t3",
      "description": "Move floating point single precision : If $t3 is not zero, set single precision $f0 to single precision value in $f1",
      "format": "R-format",
      "code": "010001 10000 ttttt sssss fffff 010011"
    }
  ],
  "movz.s": [
    {
      "syntax": "movz.s $f0,$f1,$t3",
      "description": "Move floating point single precision : If $t3 is zero, set single precision $f0 to single precision value in $f1",
      "format": "R-format",
      "code": "010001 10000 ttttt sssss fffff 010010"
    }
  ],
  "mfc1": [
    {
      "syntax": "mfc1 $t1,$f1",
      "description": "Move from Coprocessor 1 (FPU) : Set $t1 to value in Coprocessor 1 register $f1",
      "format": "R-format",
      "code": "010001 00000 fffff sssss 00000 000000"
    }
  ],
  "mtc1": [
    {
      "syntax": "mtc1 $t1,$f1",
      "description": "Move to Coprocessor 1 (FPU) : Set Coprocessor 1 register $f1 to value in $t1",
      "format": "R-format",
      "code": "010001 00100 fffff sssss 00000 000000"
    }
  ],
  "neg.d": [
    {
      "syntax": "neg.d $f2,$f4",
      "description": "Floating point negate double precision : Set double precision $f2 to negation of double precision value in $f4",
      "format": "R-format",
      "code": "010001 10001 00000 sssss fffff 000111"
    }
  ],
  "neg.s": [
    {
      "syntax": "neg.s $f0,$f1",
      "description": "Floating point negate single precision : Set single precision $f0 to negation of single precision value in $f1",
      "format": "R-format",
      "code": "010001 10000 00000 sssss fffff 000111"
    }
  ],
  "lwc1": [
    {
      "syntax": "lwc1 $f1,-100($t2)",
      "description": "Load word into Coprocessor 1 (FPU) : Set $f1 to 32-bit value from effective memory word address",
      "format": "I-format",
      "code": "110001 ttttt fffff ssssssssssssssss"
    }
  ],
  "ldc1": [
    {
      "syntax": "ldc1 $f2,-100($t2)",
      "description": "Load double word Coprocessor 1 (FPU)) : Set $f2 to 64-bit value from effective memory doubleword address",
      "format": "I-format",
      "code": "110101 ttttt fffff ssssssssssssssss"
    }
  ],
  "swc1": [
    {
      "syntax": "swc1 $f1,-100($t2)",
      "description": "Store word from Coprocesor 1 (FPU) : Store 32 bit value in $f1 to effective memory word address",
      "format": "I-format",
      "code": "111001 ttttt fffff ssssssssssssssss"
    }
  ],
  "sdc1": [
    {
      "syntax": "sdc1 $f2,-100($t2)",
      "description": "Store double word from Coprocessor 1 (FPU)) : Store 64 bit value in $f2 to effective memory doubleword address",
      "format": "I-format",
      "code": "111101 ttttt fffff ssssssssssssssss"
    }
  ],
  "teq": [
    {
      "syntax": "teq $t1,$t2",
      "description": "Trap if equal : Trap if $t1 is equal to $t2",
      "format": "R-format",
      "code": "000000 fffff sssss 00000 00000 110100"
    }
  ],
  "teqi": [
    {
      "syntax": "teqi $t1,-100",
      "description": "Trap if equal to immediate : Trap if $t1 is equal to sign-extended 16 bit immediate",
      "format": "I-format",
      "code": "000001 fffff 01100 ssssssssssssssss"
    }
  ],
  "tne": [
    {
      "syntax": "tne $t1,$t2",
      "description": "Trap if not equal : Trap if $t1 is not equal to $t2",
      "format": "R-format",
      "code": "000000 fffff sssss 00000 00000 110110"
    }
  ],
  "tnei": [
    {
      "syntax": "tnei $t1,-100",
      "description": "Trap if not equal to immediate : Trap if $t1 is not equal to sign-extended 16 bit immediate",
      "format": "I-format",
      "code": "000001 fffff 01110 ssssssssssssssss"
    }
  ],
  "tge": [
    {
      "syntax": "tge $t1,$t2",
      "description": "Trap if greater or equal : Trap if $t1 is greater than or equal to $t2",
      "format": "R-format",
      "code": "000000 fffff sssss 00000 00000 110000"
    }
  ],
  "tgeu": [
    {
      "syntax": "tgeu $t1,$t2",
      "description": "Trap if greater or equal unsigned : Trap if $t1 is greater than or equal to $t2 using unsigned comparision",
      "format": "R-format",
      "code": "000000 fffff sssss 00000 00000 110001"
    }
  ],
  "tgei": [
    {
      "syntax": "tgei $t1,-100",
      "description": "Trap if greater than or equal to immediate : Trap if $t1 greater than or equal to sign-extended 16 bit immediate",
      "format": "I-format",
      "code": "000001 fffff 01000 ssssssssssssssss"
    }
  ],
  "tgeiu": [
    {
      "syntax": "tgeiu $t1,-100",
      "description": "Trap if greater or equal to immediate unsigned : Trap if $t1 greater than or equal to sign-extended 16 bit immediate, unsigned comparison",
      "format": "I-format",
      "code": "000001 fffff 01001 ssssssssssssssss"
    }
  ],
  "tlt": [
    {
      "syntax": "tlt $t1,$t2",
      "description": "Trap if less than: Trap if $t1 less than $t2",
      "format": "R-format",
      "code": "000000 fffff sssss 00000 00000 110010"
    }
  ],
  "tltu": [
    {
      "syntax": "tltu $t1,$t2",
      "description": "Trap if less than unsigned : Trap if $t1 less than $t2, unsigned comparison",
      "format": "R-format",
      "code": "000000 fffff sssss 00000 00000 110011"
    }
  ],
  "tlti": [
    {
      "syntax": "tlti $t1,-100",
      "description": "Trap if less than immediate : Trap if $t1 less than sign-extended 16-bit immediate",
      "format": "I-format",
      "code": "000001 fffff 01010 ssssssssssssssss"
    }
  ],
  "tltiu": [
    {
      "syntax": "tltiu $t1,-100",
      "description": "Trap if less than immediate unsigned : Trap if $t1 less than sign-extended 16-bit immediate, unsigned comparison",
      "format": "I-format",
      "code": "000001 fffff 01011 ssssssssssssssss"
    }
  ],
  "eret": [
    {
      "syntax": "eret",
      "description": "Exception return : Set Program Counter to Coprocessor 0 EPC register value, set Coprocessor Status register bit 1 (exception level) to zero",
      "format": "R-format",
      "code": "010000 1 0000000000000000000 011000"
    }
  ]
}
