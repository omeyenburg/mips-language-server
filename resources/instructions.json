{
  "nop": { "format": "Register",
    "variants": [
      {
        "operands": [ ],
        "description": "Null operation: machine code is all zeroes",
        "code": "000000 00000 00000 00000 00000 000000"
      }
    ]
  },
  "add": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "$t3" ],
        "description": "Addition with overflow: set $t1 to ($t2 plus $t3)",
        "code": "000000 sssss ttttt fffff 00000 100000"
      }
    ]
  },
  "sub": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "$t3" ],
        "description": "Subtraction with overflow: set $t1 to ($t2 minus $t3)",
        "code": "000000 sssss ttttt fffff 00000 100010"
      }
    ]
  },
  "addi": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "-100" ],
        "description": "Addition immediate with overflow: set $t1 to ($t2 plus signed 16-bit immediate)",
        "code": "001000 sssss fffff tttttttttttttttt"
      }
    ]
  },
  "addu": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "$t3" ],
        "description": "Addition unsigned without overflow: set $t1 to ($t2 plus $t3), no overflow",
        "code": "000000 sssss ttttt fffff 00000 100001"
      }
    ]
  },
  "subu": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "$t3" ],
        "description": "Subtraction unsigned without overflow: set $t1 to ($t2 minus $t3), no overflow",
        "code": "000000 sssss ttttt fffff 00000 100011"
      }
    ]
  },
  "addiu": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "-100" ],
        "description": "Addition immediate unsigned without overflow: set $t1 to ($t2 plus signed 16-bit immediate), no overflow",
        "code": "001001 sssss fffff tttttttttttttttt"
      }
    ]
  },
  "mult": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2" ],
        "description": "Multiplication: Set hi to high-order 32 bits, lo to low-order 32 bits of the product of $t1 and $t2 (use mfhi to access hi, mflo to access lo)",
        "code": "000000 fffff sssss 00000 00000 011000"
      }
    ]
  },
  "multu": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2" ],
        "description": "Multiplication unsigned: Set HI to high-order 32 bits, LO to low-order 32 bits of the product of unsigned $t1 and $t2 (use mfhi to access HI, mflo to access LO)",
        "code": "000000 fffff sssss 00000 00000 011001"
      }
    ]
  },
  "mul": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "$t3" ],
        "description": "Multiplication without overflow : Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of the product of $t2 and $t3 (use mfhi to access HI, mflo to access LO)",
        "code": "011100 sssss ttttt fffff 00000 000010"
      }
    ]
  },
  "madd": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2" ],
        "description": "Multiply add: Multiply $t1 by $t2 then increment HI by high-order 32 bits of product, increment LO by low-order 32 bits of product (use mfhi to access HI, mflo to access LO)",
        "code": "011100 fffff sssss 00000 00000 000000"
      }
    ]
  },
  "maddu": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2" ],
        "description": "Multiply add unsigned: Multiply $t1 by $t2 then increment HI by high-order 32 bits of product, increment LO by low-order 32 bits of product, unsigned (use mfhi to access HI, mflo to access LO)",
        "code": "011100 fffff sssss 00000 00000 000001"
      }
    ]
  },
  "msub": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2" ],
        "description": "Multiply subtract: Multiply $t1 by $t2 then decrement HI by high-order 32 bits of product, decrement LO by low-order 32 bits of product (use mfhi to access HI, mflo to access LO)",
        "code": "011100 fffff sssss 00000 00000 000100"
      }
    ]
  },
  "msubu": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2" ],
        "description": "Multiply subtract unsigned: Multiply $t1 by $t2 then decrement HI by high-order 32 bits of product, decement LO by low-order 32 bits of product, unsigned (use mfhi to access HI, mflo to access LO)",
        "code": "011100 fffff sssss 00000 00000 000101"
      }
    ]
  },
  "div": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2" ],
        "description": "Division with overflow: Divide $t1 by $t2 then set LO to quotient and HI to remainder (use mfhi to access HI, mflo to access LO)",
        "code": "000000 fffff sssss 00000 00000 011010"
      }
    ]
  },
  "divu": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2" ],
        "description": "Division unsigned without overflow: Divide unsigned $t1 by $t2 then set LO to quotient and HI to remainder (use mfhi to access HI, mflo to access LO)",
        "code": "000000 fffff sssss 00000 00000 011011"
      }
    ]
  },
  "mfhi": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1" ],
        "description": "Move from HI register: Set $t1 to contents of HI (see multiply and divide operations)",
        "code": "000000 00000 00000 fffff 00000 010000"
      }
    ]
  },
  "mflo": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1" ],
        "description": "Move from LO register: Set $t1 to contents of LO (see multiply and divide operations)",
        "code": "000000 00000 00000 fffff 00000 010010"
      }
    ]
  },
  "mthi": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1" ],
        "description": "Move to HI registerr: Set HI to contents of $t1 (see multiply and divide operations)",
        "code": "000000 fffff 00000 00000 00000 010001"
      }
    ]
  },
  "mtlo": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1" ],
        "description": "Move to LO register: Set LO to contents of $t1 (see multiply and divide operations)",
        "code": "000000 fffff 00000 00000 00000 010011"
      }
    ]
  },
  "and": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "$t3" ],
        "description": "Bitwise AND: Set $t1 to bitwise AND of $t2 and $t3",
        "code": "000000 sssss ttttt fffff 00000 100100"
      }
    ]
  },
  "or": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "$t3" ],
        "description": "Bitwise OR: Set $t1 to bitwise OR of $t2 and $t3",
        "code": "000000 sssss ttttt fffff 00000 100101"
      }
    ]
  },
  "andi": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "100" ],
        "description": "Bitwise AND immediate: Set $t1 to bitwise AND of $t2 and zero-extended 16-bit immediate",
        "code": "001100 sssss fffff tttttttttttttttt"
      }
    ]
  },
  "ori": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "100" ],
        "description": "Bitwise OR immediate: Set $t1 to bitwise OR of $t2 and zero-extended 16-bit immediate",
        "code": "001101 sssss fffff tttttttttttttttt"
      }
    ]
  },
  "nor": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "$t3" ],
        "description": "Bitwise NOR: Set $t1 to bitwise NOR of $t2 and $t3",
        "code": "000000 sssss ttttt fffff 00000 100111"
      }
    ]
  },
  "xor": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "$t3" ],
        "description": "Bitwise XOR (exclusive OR): Set $t1 to bitwise XOR of $t2 and $t3",
        "code": "000000 sssss ttttt fffff 00000 100110"
      }
    ]
  },
  "xori": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "100" ],
        "description": "Bitwise XOR immediate: Set $t1 to bitwise XOR of $t2 and zero-extended 16-bit immediate",
        "code": "001110 sssss fffff tttttttttttttttt"
      }
    ]
  },
  "sll": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "10" ],
        "description": "Shift left logical: Set $t1 to result of shifting $t2 left by number of bits specified by immediate",
        "code": "000000 00000 sssss fffff ttttt 000000"
      }
    ]
  },
  "sllv": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "$t3" ],
        "description": "Shift left logical variable: Set $t1 to result of shifting $t2 left by number of bits specified by value in low-order 5 bits of $t3",
        "code": "000000 ttttt sssss fffff 00000 000100"
      }
    ]
  },
  "srl": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "10" ],
        "description": "Shift right logical: Set $t1 to result of shifting $t2 right by number of bits specified by immediate",
        "code": "000000 00000 sssss fffff ttttt 000010"
      }
    ]
  },
  "sra": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "10" ],
        "description": "Shift right arithmetic: Set $t1 to result of sign-extended shifting $t2 right by number of bits specified by immediate",
        "code": "000000 00000 sssss fffff ttttt 000011"
      }
    ]
  },
  "srav": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "$t3" ],
        "description": "Shift right arithmetic variable: Set $t1 to result of sign-extended shifting $t2 right by number of bits specified by value in low-order 5 bits of $t3",
        "code": "000000 ttttt sssss fffff 00000 000111"
      }
    ]
  },
  "srlv": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "$t3" ],
        "description": "Shift right logical variable: Set $t1 to result of shifting $t2 right by number of bits specified by value in low-order 5 bits of $t3",
        "code": "000000 ttttt sssss fffff 00000 000110"
      }
    ]
  },
  "lw": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100($t2)" ],
        "description": "Load word: Set $t1 to contents of effective memory word address",
        "code": "100011 ttttt fffff ssssssssssssssss"
      }
    ]
  },
  "ll": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100($t2)" ],
        "description": "Load linked: Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.",
        "code": "110000 ttttt fffff ssssssssssssssss"
      }
    ]
  },
  "lwl": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100($t2)" ],
        "description": "Load word left: Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word",
        "code": "100010 ttttt fffff ssssssssssssssss"
      }
    ]
  },
  "lwr": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100($t2)" ],
        "description": "Load word right: Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word",
        "code": "100110 ttttt fffff ssssssssssssssss"
      }
    ]
  },
  "sw": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100($t2)" ],
        "description": "Store word: Store contents of $t1 into effective memory word address",
        "code": "101011 ttttt fffff ssssssssssssssss"
      }
    ]
  },
  "sc": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100($t2)" ],
        "description": "Store conditional: Paired with Load Linked (ll) to perform atomic read-modify-write.  Stores $t1 value into effective address, then sets $t1 to 1 for success.  Always succeeds because MARS does not simulate multiple processors.",
        "code": "111000 ttttt fffff ssssssssssssssss"
      }
    ]
  },
  "swl": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100($t2)" ],
        "description": "Store word left: Store high-order 1 to 4 bytes of $t1 into memory, starting with effective byte address and continuing through the low-order byte of its word",
        "code": "101010 ttttt fffff ssssssssssssssss"
      }
    ]
  },
  "swr": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100($t2)" ],
        "description": "Store word right: Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective byte address and continuing through that byte address",
        "code": "101110 ttttt fffff ssssssssssssssss"
      }
    ]
  },
  "lui": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "100" ],
        "description": "Load upper immediate: Set high-order 16 bits of $t1 to 16-bit immediate and low-order 16 bits to 0",
        "code": "001111 00000 fffff ssssssssssssssss"
      }
    ]
  },
  "beq": {
    "format": "Immediate branch",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "label" ],
        "description": "Branch if equal: Branch to statement at label's address if $t1 and $t2 are equal",
        "code": "000100 fffff sssss tttttttttttttttt"
      }
    ]
  },
  "bne": {
    "format": "Immediate branch",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "label" ],
        "description": "Branch if not equal: Branch to statement at label's address if $t1 and $t2 are not equal",
        "code": "000101 fffff sssss tttttttttttttttt"
      }
    ]
  },
  "bgez": {
    "format": "Immediate branch",
    "variants": [
      {
        "operands": [ "$t1", "label" ],
        "description": "Branch if greater than or equal to zero: Branch to statement at label's address if $t1 is greater than or equal to zero",
        "code": "000001 fffff 00001 ssssssssssssssss"
      }
    ]
  },
  "bgezal": {
    "format": "Immediate branch",
    "variants": [
      {
        "operands": [ "$t1", "label" ],
        "description": "Branch if greater then or equal to zero and link: If $t1 is greater than or equal to zero, then set $ra to the Program Counter and branch to statement at label's address",
        "code": "000001 fffff 10001 ssssssssssssssss"
      }
    ]
  },
  "bgtz": {
    "format": "Immediate branch",
    "variants": [
      {
        "operands": [ "$t1", "label" ],
        "description": "Branch if greater than zero: Branch to statement at label's address if $t1 is greater than zero",
        "code": "000111 fffff 00000 ssssssssssssssss"
      }
    ]
  },
  "blez": {
    "format": "Immediate branch",
    "variants": [
      {
        "operands": [ "$t1", "label" ],
        "description": "Branch if less than or equal to zero: Branch to statement at label's address if $t1 is less than or equal to zero",
        "code": "000110 fffff 00000 ssssssssssssssss"
      }
    ]
  },
  "bltz": {
    "format": "Immediate branch",
    "variants": [
      {
        "operands": [ "$t1", "label" ],
        "description": "Branch if less than zero: Branch to statement at label's address if $t1 is less than zero",
        "code": "000001 fffff 00000 ssssssssssssssss"
      }
    ]
  },
  "bltzal": {
    "format": "Immediate branch",
    "variants": [
      {
        "operands": [ "$t1", "label" ],
        "description": "Branch if less than zero and link: If $t1 is less than or equal to zero, then set $ra to the Program Counter and branch to statement at label's address",
        "code": "000001 fffff 10000 ssssssssssssssss"
      }
    ]
  },
  "slt": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "$t3" ],
        "description": "Set less than: If $t2 is less than $t3, then set $t1 to 1 else set $t1 to 0",
        "code": "000000 sssss ttttt fffff 00000 101010"
      }
    ]
  },
  "sltu": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "$t3" ],
        "description": "Set less than unsigned: If $t2 is less than $t3 using unsigned comparision, then set $t1 to 1 else set $t1 to 0",
        "code": "000000 sssss ttttt fffff 00000 101011"
      }
    ]
  },
  "slti": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "-100" ],
        "description": "Set less than immediate: If $t2 is less than sign-extended 16-bit immediate, then set $t1 to 1 else set $t1 to 0",
        "code": "001010 sssss fffff tttttttttttttttt"
      }
    ]
  },
  "sltiu": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "-100" ],
        "description": "Set less than immediate unsigned: If $t2 is less than  sign-extended 16-bit immediate using unsigned comparison, then set $t1 to 1 else set $t1 to 0",
        "code": "001011 sssss fffff tttttttttttttttt"
      }
    ]
  },
  "movn": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "$t3" ],
        "description": "Move conditional not zero: Set $t1 to $t2 if $t3 is not zero",
        "code": "000000 sssss ttttt fffff 00000 001011"
      }
    ]
  },
  "movz": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2", "$t3" ],
        "description": "Move conditional zero: Set $t1 to $t2 if $t3 is zero",
        "code": "000000 sssss ttttt fffff 00000 001010"
      }
    ]
  },
  "movf": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2" ],
        "description": "Move if FP condition flag 0 false: Set $t1 to $t2 if FPU (Coprocessor 1) condition flag 0 is false (zero)",
        "code": "000000 sssss 000 00 fffff 00000 000001"
      },
      {
        "operands": [ "$t1", "$t2", "1" ],
        "description": "Move if specified FP condition flag false: Set $t1 to $t2 if FPU (Coprocessor 1) condition flag specified by the immediate is false (zero)",
        "code": "000000 sssss ttt 00 fffff 00000 000001"
      }
    ]
  },
  "movt": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2" ],
        "description": "Move if FP condition flag 0 true: Set $t1 to $t2 if FPU (Coprocessor 1) condition flag 0 is true (one)",
        "code": "000000 sssss 000 01 fffff 00000 000001"
      },
      {
        "operands": [ "$t1", "$t2", "1" ],
        "description": "Move if specfied FP condition flag true: Set $t1 to $t2 if FPU (Coprocessor 1) condition flag specified by the immediate is true (one)",
        "code": "000000 sssss ttt 01 fffff 00000 000001"
      }
    ]
  },
  "break": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "100" ],
        "description": "Break execution with code: Terminate program execution with specified exception code",
        "code": "000000 ffffffffffffffffffff 001101"
      },
      {
        "operands": [ ],
        "description": "Break execution: Terminate program execution with exception",
        "code": "000000 00000 00000 00000 00000 001101"
      }
    ]
  },
  "syscall": {
    "format": "Register",
    "variants": [
      {
        "operands": [ ],
        "description": "Issue a system call: Execute the system call specified by value in $v0",
        "code": "000000 00000 00000 00000 00000 001100"
      }
    ]
  },
  "j": {
    "format": "Jump",
    "variants": [
      {
        "operands": [ "target" ],
        "description": "Jump unconditionally: Jump to statement at target address",
        "code": "000010 ffffffffffffffffffffffffff"
      }
    ]
  },
  "jr": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1" ],
        "description": "Jump register unconditionally: Jump to statement whose address is in $t1",
        "code": "000000 fffff 00000 00000 00000 001000"
      }
    ]
  },
  "jal": {
    "format": "Jump",
    "variants": [
      {
        "operands": [ "target" ],
        "description": "Jump and link: Set $ra to Program Counter (return address) then jump to statement at target address",
        "code": "000011 ffffffffffffffffffffffffff"
      }
    ]
  },
  "jalr": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2" ],
        "description": "Jump and link register: Set $t1 to Program Counter (return address) then jump to statement whose address is in $t2",
        "code": "000000 sssss 00000 fffff 00000 001001"
      },
      {
        "operands": [ "$t1" ],
        "description": "Jump and link register: Set $ra to Program Counter (return address) then jump to statement whose address is in $t1",
        "code": "000000 fffff 00000 11111 00000 001001"
      }
    ]
  },
  "lb": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100($t2)" ],
        "description": "Load byte: Set $t1 to sign-extended 8-bit value from effective memory byte address",
        "code": "100000 ttttt fffff ssssssssssssssss"
      }
    ]
  },
  "lh": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100($t2)" ],
        "description": "Load halfword: Set $t1 to sign-extended 16-bit value from effective memory halfword address",
        "code": "100001 ttttt fffff ssssssssssssssss"
      }
    ]
  },
  "lhu": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100($t2)" ],
        "description": "Load halfword unsigned: Set $t1 to zero-extended 16-bit value from effective memory halfword address",
        "code": "100101 ttttt fffff ssssssssssssssss"
      }
    ]
  },
  "lbu": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100($t2)" ],
        "description": "Load byte unsigned: Set $t1 to zero-extended 8-bit value from effective memory byte address",
        "code": "100100 ttttt fffff ssssssssssssssss"
      }
    ]
  },
  "sb": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100($t2)" ],
        "description": "Store byte: Store the low-order 8 bits of $t1 into the effective memory byte address",
        "code": "101000 ttttt fffff ssssssssssssssss"
      }
    ]
  },
  "sh": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100($t2)" ],
        "description": "Store halfword: Store the low-order 16 bits of $t1 into the effective memory halfword address",
        "code": "101001 ttttt fffff ssssssssssssssss"
      }
    ]
  },
  "mfc0": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$8" ],
        "description": "Move from Coprocessor 0: Set $t1 to the value stored in Coprocessor 0 register $8",
        "code": "010000 00000 fffff sssss 00000 000000"
      }
    ]
  },
  "mtc0": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$8" ],
        "description": "Move to Coprocessor 0: Set Coprocessor 0 register $8 to value stored in $t1",
        "code": "010000 00100 fffff sssss 00000 000000"
      }
    ]
  },
  "add.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1", "$f3" ],
        "description": "Floating point addition single precision: Set $f0 to single-precision floating point value of $f1 plus $f3",
        "code": "010001 10000 ttttt sssss fffff 000000"
      }
    ]
  },
  "sub.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1", "$f3" ],
        "description": "Floating point subtraction single precision: Set $f0 to single-precision floating point value of $f1  minus $f3",
        "code": "010001 10000 ttttt sssss fffff 000001"
      }
    ]
  },
  "mul.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1", "$f3" ],
        "description": "Floating point multiplication single precision: Set $f0 to single-precision floating point value of $f1 times $f3",
        "code": "010001 10000 ttttt sssss fffff 000010"
      }
    ]
  },
  "div.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1", "$f3" ],
        "description": "Floating point division single precision: Set $f0 to single-precision floating point value of $f1 divided by $f3",
        "code": "010001 10000 ttttt sssss fffff 000011"
      }
    ]
  },
  "sqrt.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1" ],
        "description": "Square root single precision: Set $f0 to single-precision floating point square root of $f1",
        "code": "010001 10000 00000 sssss fffff 000100"
      }
    ]
  },
  "floor.w.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1" ],
        "description": "Floor single precision to word: Set $f0 to 32-bit integer floor of single-precision float in $f1",
        "code": "010001 10000 00000 sssss fffff 001111"
      }
    ]
  },
  "ceil.w.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1" ],
        "description": "Ceiling single precision to word: Set $f0 to 32-bit integer ceiling of single-precision float in $f1",
        "code": "010001 10000 00000 sssss fffff 001110"
      }
    ]
  },
  "round.w.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1" ],
        "description": "Round single precision to word: Set $f0 to 32-bit integer round of single-precision float in $f1",
        "code": "010001 10000 00000 sssss fffff 001100"
      }
    ]
  },
  "trunc.w.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1" ],
        "description": "Truncate single precision to word: Set $f0 to 32-bit integer truncation of single-precision float in $f1",
        "code": "010001 10000 00000 sssss fffff 001101"
      }
    ]
  },
  "add.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f2", "$f4", "$f6" ],
        "description": "Floating point addition double precision: Set $f2 to double-precision floating point value of $f4 plus $f6",
        "code": "010001 10001 ttttt sssss fffff 000000"
      }
    ]
  },
  "sub.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f2", "$f4", "$f6" ],
        "description": "Floating point subtraction double precision: Set $f2 to double-precision floating point value of $f4 minus $f6",
        "code": "010001 10001 ttttt sssss fffff 000001"
      }
    ]
  },
  "mul.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f2", "$f4", "$f6" ],
        "description": "Floating point multiplication double precision: Set $f2 to double-precision floating point value of $f4 times $f6",
        "code": "010001 10001 ttttt sssss fffff 000010"
      }
    ]
  },
  "div.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f2", "$f4", "$f6" ],
        "description": "Floating point division double precision: Set $f2 to double-precision floating point value of $f4 divided by $f6",
        "code": "010001 10001 ttttt sssss fffff 000011"
      }
    ]
  },
  "sqrt.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f2", "$f4" ],
        "description": "Square root double precision: Set $f2 to double-precision floating point square root of $f4",
        "code": "010001 10001 00000 sssss fffff 000100"
      }
    ]
  },
  "floor.w.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f1", "$f2" ],
        "description": "Floor double precision to word: Set $f1 to 32-bit integer floor of double-precision float in $f2",
        "code": "010001 10001 00000 sssss fffff 001111"
      }
    ]
  },
  "ceil.w.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f1", "$f2" ],
        "description": "Ceiling double precision to word: Set $f1 to 32-bit integer ceiling of double-precision float in $f2",
        "code": "010001 10001 00000 sssss fffff 001110"
      }
    ]
  },
  "round.w.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f1", "$f2" ],
        "description": "Round double precision to word: Set $f1 to 32-bit integer round of double-precision float in $f2",
        "code": "010001 10001 00000 sssss fffff 001100"
      }
    ]
  },
  "trunc.w.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f1", "$f2" ],
        "description": "Truncate double precision to word: Set $f1 to 32-bit integer truncation of double-precision float in $f2",
        "code": "010001 10001 00000 sssss fffff 001101"
      }
    ]
  },
  "bc1t": {
    "format": "Immediate branch",
    "variants": [
      {
        "operands": [ "label" ],
        "description": "Branch if FP condition flag 0 true (BC1T, not BCLT): If Coprocessor 1 condition flag 0 is true (one) then branch to statement at label's address",
        "code": "010001 01000 00001 ffffffffffffffff"
      },
      {
        "operands": [ "1", "label" ],
        "description": "Branch if specified FP condition flag true (BC1T, not BCLT): If Coprocessor 1 condition flag specified by immediate is true (one) then branch to statement at label's address",
        "code": "010001 01000 fff 01 ssssssssssssssss"
      }
    ]
  },
  "bc1f": {
    "format": "Immediate branch",
    "variants": [
      {
        "operands": [ "label" ],
        "description": "Branch if FP condition flag 0 false (BC1F, not BCLF): If Coprocessor 1 condition flag 0 is false (zero) then branch to statement at label's address",
        "code": "010001 01000 00000 ffffffffffffffff"
      },
      {
        "operands": [ "1", "label" ],
        "description": "Branch if specified FP condition flag false (BC1F, not BCLF): If Coprocessor 1 condition flag specified by immediate is false (zero) then branch to statement at label's address",
        "code": "010001 01000 fff 00 ssssssssssssssss"
      }
    ]
  },
  "c.eq.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1" ],
        "description": "Compare equal single precision: If $f0 is equal to $f1, set Coprocessor 1 condition flag 0 true else set it false",
        "code": "010001 10000 sssss fffff 00000 110010"
      },
      {
        "operands": [ "1", "$f0", "$f1" ],
        "description": "Compare equal single precision: If $f0 is equal to $f1, set Coprocessor 1 condition flag specied by immediate to true else set it to false",
        "code": "010001 10000 ttttt sssss fff 00 11 0010"
      }
    ]
  },
  "c.le.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1" ],
        "description": "Compare less or equal single precision: If $f0 is less than or equal to $f1, set Coprocessor 1 condition flag 0 true else set it false",
        "code": "010001 10000 sssss fffff 00000 111110"
      },
      {
        "operands": [ "1", "$f0", "$f1" ],
        "description": "Compare less or equal single precision: If $f0 is less than or equal to $f1, set Coprocessor 1 condition flag specified by immediate to true else set it to false",
        "code": "010001 10000 ttttt sssss fff 00 111110"
      }
    ]
  },
  "c.lt.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1" ],
        "description": "Compare less than single precision: If $f0 is less than $f1, set Coprocessor 1 condition flag 0 true else set it false",
        "code": "010001 10000 sssss fffff 00000 111100"
      },
      {
        "operands": [ "1", "$f0", "$f1" ],
        "description": "Compare less than single precision: If $f0 is less than $f1, set Coprocessor 1 condition flag specified by immediate to true else set it to false",
        "code": "010001 10000 ttttt sssss fff 00 111100"
      }
    ]
  },
  "c.eq.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f2", "$f4" ],
        "description": "Compare equal double precision: If $f2 is equal to $f4 (double-precision), set Coprocessor 1 condition flag 0 true else set it false",
        "code": "010001 10001 sssss fffff 00000 110010"
      },
      {
        "operands": [ "1", "$f2", "$f4" ],
        "description": "Compare equal double precision: If $f2 is equal to $f4 (double-precision), set Coprocessor 1 condition flag specified by immediate to true else set it to false",
        "code": "010001 10001 ttttt sssss fff 00 110010"
      }
    ]
  },
  "c.le.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f2", "$f4" ],
        "description": "Compare less or equal double precision: If $f2 is less than or equal to $f4 (double-precision), set Coprocessor 1 condition flag 0 true else set it false",
        "code": "010001 10001 sssss fffff 00000 111110"
      },
      {
        "operands": [ "1", "$f2", "$f4" ],
        "description": "Compare less or equal double precision: If $f2 is less than or equal to $f4 (double-precision), set Coprocessor 1 condition flag specfied by immediate true else set it false",
        "code": "010001 10001 ttttt sssss fff 00 111110"
      }
    ]
  },
  "c.lt.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f2", "$f4" ],
        "description": "Compare less than double precision: If $f2 is less than $f4 (double-precision), set Coprocessor 1 condition flag 0 true else set it false",
        "code": "010001 10001 sssss fffff 00000 111100"
      },
      {
        "operands": [ "1", "$f2", "$f4" ],
        "description": "Compare less than double precision: If $f2 is less than $f4 (double-precision), set Coprocessor 1 condition flag specified by immediate to true else set it to false",
        "code": "010001 10001 ttttt sssss fff 00 111100"
      }
    ]
  },
  "abs.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1" ],
        "description": "Floating point absolute value single precision: Set $f0 to absolute value of $f1, single precision",
        "code": "010001 10000 00000 sssss fffff 000101"
      }
    ]
  },
  "abs.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f2", "$f4" ],
        "description": "Floating point absolute value double precision: Set $f2 to absolute value of $f4, double precision",
        "code": "010001 10001 00000 sssss fffff 000101"
      }
    ]
  },
  "cvt.d.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f2", "$f1" ],
        "description": "Convert from single precision to double precision: Set $f2 to double precision equivalent of single precision value in $f1",
        "code": "010001 10000 00000 sssss fffff 100001"
      }
    ]
  },
  "cvt.d.w": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f2", "$f1" ],
        "description": "Convert from word to double precision: Set $f2 to double precision equivalent of 32-bit integer value in $f1",
        "code": "010001 10100 00000 sssss fffff 100001"
      }
    ]
  },
  "cvt.s.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f1", "$f2" ],
        "description": "Convert from double precision to single precision: Set $f1 to single precision equivalent of double precision value in $f2",
        "code": "010001 10001 00000 sssss fffff 100000"
      }
    ]
  },
  "cvt.s.w": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1" ],
        "description": "Convert from word to single precision: Set $f0 to single precision equivalent of 32-bit integer value in $f2",
        "code": "010001 10100 00000 sssss fffff 100000"
      }
    ]
  },
  "cvt.w.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f1", "$f2" ],
        "description": "Convert from double precision to word: Set $f1 to 32-bit integer equivalent of double precision value in $f2",
        "code": "010001 10001 00000 sssss fffff 100100"
      }
    ]
  },
  "cvt.w.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1" ],
        "description": "Convert from single precision to word: Set $f0 to 32-bit integer equivalent of single precision value in $f1",
        "code": "010001 10000 00000 sssss fffff 100100"
      }
    ]
  },
  "mov.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f2", "$f4" ],
        "description": "Move floating point double precision: Set double precision $f2 to double precision value in $f4",
        "code": "010001 10001 00000 sssss fffff 000110"
      }
    ]
  },
  "movf.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f2", "$f4" ],
        "description": "Move floating point double precision: If condition flag 0 false, set double precision $f2 to double precision value in $f4",
        "code": "010001 10001 000 00 sssss fffff 010001"
      },
      {
        "operands": [ "$f2", "$f4", "1" ],
        "description": "Move floating point double precision: If condition flag specified by immediate is false, set double precision $f2 to double precision value in $f4",
        "code": "010001 10001 ttt 00 sssss fffff 010001"
      }
    ]
  },
  "movt.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f2", "$f4" ],
        "description": "Move floating point double precision: If condition flag 0 true, set double precision $f2 to double precision value in $f4",
        "code": "010001 10001 000 01 sssss fffff 010001"
      },
      {
        "operands": [ "$f2", "$f4", "1" ],
        "description": "Move floating point double precision: If condition flag specified by immediate is true, set double precision $f2 to double precision value in $f4e",
        "code": "010001 10001 ttt 01 sssss fffff 010001"
      }
    ]
  },
  "movn.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f2", "$f4", "$t3" ],
        "description": "Move floating point double precision: If $t3 is not zero, set double precision $f2 to double precision value in $f4",
        "code": "010001 10001 ttttt sssss fffff 010011"
      }
    ]
  },
  "movz.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f2", "$f4", "$t3" ],
        "description": "Move floating point double precision: If $t3 is zero, set double precision $f2 to double precision value in $f4",
        "code": "010001 10001 ttttt sssss fffff 010010"
      }
    ]
  },
  "mov.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1" ],
        "description": "Move floating point single precision: Set single precision $f0 to single precision value in $f1",
        "code": "010001 10000 00000 sssss fffff 000110"
      }
    ]
  },
  "movf.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1" ],
        "description": "Move floating point single precision: If condition flag 0 is false, set single precision $f0 to single precision value in $f1",
        "code": "010001 10000 000 00 sssss fffff 010001"
      },
      {
        "operands": [ "$f0", "$f1", "1" ],
        "description": "Move floating point single precision: If condition flag specified by immediate is false, set single precision $f0 to single precision value in $f1e",
        "code": "010001 10000 ttt 00 sssss fffff 010001"
      }
    ]
  },
  "movt.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1" ],
        "description": "Move floating point single precision: If condition flag 0 is true, set single precision $f0 to single precision value in $f1e",
        "code": "010001 10000 000 01 sssss fffff 010001"
      },
      {
        "operands": [ "$f0", "$f1", "1" ],
        "description": "Move floating point single precision: If condition flag specified by immediate is true, set single precision $f0 to single precision value in $f1e",
        "code": "010001 10000 ttt 01 sssss fffff 010001"
      }
    ]
  },
  "movn.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1", "$t3" ],
        "description": "Move floating point single precision: If $t3 is not zero, set single precision $f0 to single precision value in $f1",
        "code": "010001 10000 ttttt sssss fffff 010011"
      }
    ]
  },
  "movz.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1", "$t3" ],
        "description": "Move floating point single precision: If $t3 is zero, set single precision $f0 to single precision value in $f1",
        "code": "010001 10000 ttttt sssss fffff 010010"
      }
    ]
  },
  "mfc1": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$f1" ],
        "description": "Move from Coprocessor 1 (FPU): Set $t1 to value in Coprocessor 1 register $f1",
        "code": "010001 00000 fffff sssss 00000 000000"
      }
    ]
  },
  "mtc1": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$f1" ],
        "description": "Move to Coprocessor 1 (FPU): Set Coprocessor 1 register $f1 to value in $t1",
        "code": "010001 00100 fffff sssss 00000 000000"
      }
    ]
  },
  "neg.d": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f2", "$f4" ],
        "description": "Floating point negate double precision: Set double precision $f2 to negation of double precision value in $f4",
        "code": "010001 10001 00000 sssss fffff 000111"
      }
    ]
  },
  "neg.s": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$f0", "$f1" ],
        "description": "Floating point negate single precision: Set single precision $f0 to negation of single precision value in $f1",
        "code": "010001 10000 00000 sssss fffff 000111"
      }
    ]
  },
  "lwc1": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$f1", "-100($t2)" ],
        "description": "Load word into Coprocessor 1 (FPU): Set $f1 to 32-bit value from effective memory word address",
        "code": "110001 ttttt fffff ssssssssssssssss"
      }
    ]
  },
  "ldc1": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$f2", "-100($t2)" ],
        "description": "Load double word Coprocessor 1 (FPU)): Set $f2 to 64-bit value from effective memory doubleword address",
        "code": "110101 ttttt fffff ssssssssssssssss"
      }
    ]
  },
  "swc1": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$f1", "-100($t2)" ],
        "description": "Store word from Coprocesor 1 (FPU): Store 32 bit value in $f1 to effective memory word address",
        "code": "111001 ttttt fffff ssssssssssssssss"
      }
    ]
  },
  "sdc1": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$f2", "-100($t2)" ],
        "description": "Store double word from Coprocessor 1 (FPU)): Store 64 bit value in $f2 to effective memory doubleword address",
        "code": "111101 ttttt fffff ssssssssssssssss"
      }
    ]
  },
  "teq": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2" ],
        "description": "Trap if equal: Trap if $t1 is equal to $t2",
        "code": "000000 fffff sssss 00000 00000 110100"
      }
    ]
  },
  "teqi": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100" ],
        "description": "Trap if equal to immediate: Trap if $t1 is equal to sign-extended 16 bit immediate",
        "code": "000001 fffff 01100 ssssssssssssssss"
      }
    ]
  },
  "tne": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2" ],
        "description": "Trap if not equal: Trap if $t1 is not equal to $t2",
        "code": "000000 fffff sssss 00000 00000 110110"
      }
    ]
  },
  "tnei": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100" ],
        "description": "Trap if not equal to immediate: Trap if $t1 is not equal to sign-extended 16 bit immediate",
        "code": "000001 fffff 01110 ssssssssssssssss"
      }
    ]
  },
  "tge": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2" ],
        "description": "Trap if greater or equal: Trap if $t1 is greater than or equal to $t2",
        "code": "000000 fffff sssss 00000 00000 110000"
      }
    ]
  },
  "tgeu": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2" ],
        "description": "Trap if greater or equal unsigned: Trap if $t1 is greater than or equal to $t2 using unsigned comparision",
        "code": "000000 fffff sssss 00000 00000 110001"
      }
    ]
  },
  "tgei": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100" ],
        "description": "Trap if greater than or equal to immediate: Trap if $t1 greater than or equal to sign-extended 16 bit immediate",
        "code": "000001 fffff 01000 ssssssssssssssss"
      }
    ]
  },
  "tgeiu": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100" ],
        "description": "Trap if greater or equal to immediate unsigned: Trap if $t1 greater than or equal to sign-extended 16 bit immediate, unsigned comparison",
        "code": "000001 fffff 01001 ssssssssssssssss"
      }
    ]
  },
  "tlt": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2" ],
        "description": "Trap if less than: Trap if $t1 less than $t2",
        "code": "000000 fffff sssss 00000 00000 110010"
      }
    ]
  },
  "tltu": {
    "format": "Register",
    "variants": [
      {
        "operands": [ "$t1", "$t2" ],
        "description": "Trap if less than unsigned: Trap if $t1 less than $t2, unsigned comparison",
        "code": "000000 fffff sssss 00000 00000 110011"
      }
    ]
  },
  "tlti": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100" ],
        "description": "Trap if less than immediate: Trap if $t1 less than sign-extended 16-bit immediate",
        "code": "000001 fffff 01010 ssssssssssssssss"
      }
    ]
  },
  "tltiu": {
    "format": "Immediate",
    "variants": [
      {
        "operands": [ "$t1", "-100" ],
        "description": "Trap if less than immediate unsigned: Trap if $t1 less than sign-extended 16-bit immediate, unsigned comparison",
        "code": "000001 fffff 01011 ssssssssssssssss"
      }
    ]
  },
  "eret": {
    "format": "Register",
    "variants": [
      {
        "operands": [ ],
        "description": "Exception return: Set Program Counter to Coprocessor 0 EPC register value, set Coprocessor Status register bit 1 (exception level) to zero",
        "code": "010000 1 0000000000000000000 011000"
      }
    ]
  }
}
