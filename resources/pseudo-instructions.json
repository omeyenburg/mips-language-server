{
  "not": [
    {
      "pattern": "not $t1,$t2",
      "replacement": [
        "nor RG1, RG2, $0"
      ],
      "description": "Bitwise NOT (bit inversion)"
    }
  ],
  "add": [
    {
      "pattern": "add $t1,$t2,-100",
      "replacement": [
        "addi RG1, RG2, VL3"
      ],
      "description": "ADDition: set $t1 to ($t2 plus 16-bit immediate)"
    },
    {
      "pattern": "add $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "add RG1, RG2, $1"
      ],
      "description": "ADDition: set $t1 to ($t2 plus 32-bit immediate)"
    }
  ],
  "addu": [
    {
      "pattern": "addu $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "addu RG1, RG2, $1"
      ],
      "description": "ADDition Unsigned: set $t1 to ($t2 plus 32-bit immediate), no overflow"
    }
  ],
  "addi": [
    {
      "pattern": "addi $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "add RG1, RG2, $1"
      ],
      "description": "ADDition Immediate: set $t1 to ($t2 plus 32-bit immediate)"
    }
  ],
  "addiu": [
    {
      "pattern": "addiu $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "addu RG1, RG2, $1"
      ],
      "description": "ADDition Immediate Unsigned: set $t1 to ($t2 plus 32-bit immediate), no overflow"
    }
  ],
  "sub": [
    {
      "pattern": "sub $t1,$t2,-100",
      "replacement": [
        "",
        "addi $1, $0, VL3",
        "sub RG1, RG2, $1"
      ],
      "description": "SUBtraction: set $t1 to ($t2 minus 16-bit immediate)"
    },
    {
      "pattern": "sub $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "sub RG1, RG2, $1"
      ],
      "description": "SUBtraction: set $t1 to ($t2 minus 32-bit immediate)"
    }
  ],
  "subu": [
    {
      "pattern": "subu $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "subu RG1, RG2, $1"
      ],
      "description": "SUBtraction Unsigned: set $t1 to ($t2 minus 32-bit immediate), no overflow"
    }
  ],
  "subi": [
    {
      "pattern": "subi $t1,$t2,-100",
      "replacement": [
        "",
        "addi $1, $0, VL3",
        "sub RG1, RG2, $1"
      ],
      "description": "SUBtraction Immediate: set $t1 to ($t2 minus 16-bit immediate)"
    },
    {
      "pattern": "subi $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "sub RG1, RG2, $1"
      ],
      "description": "SUBtraction Immediate: set $t1 to ($t2 minus 32-bit immediate)"
    }
  ],
  "subiu": [
    {
      "pattern": "subiu $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "subu RG1, RG2, $1"
      ],
      "description": "SUBtraction Immediate Unsigned: set $t1 to ($t2 minus 32-bit immediate), no overflow"
    }
  ],
  "and": [
    {
      "pattern": "and $t1,$t2,100",
      "replacement": [
        "andi RG1, RG2, VL3U"
      ],
      "description": "AND: set $t1 to ($t2 bitwise-AND 16-bit unsigned immediate)"
    },
    {
      "pattern": "and $t1,100",
      "replacement": [
        "andi RG1, RG1, VL2U"
      ],
      "description": "AND: set $t1 to ($t1 bitwise-AND 16-bit unsigned immediate)"
    }
  ],
  "or": [
    {
      "pattern": "or $t1,$t2,100",
      "replacement": [
        "ori RG1, RG2, VL3U"
      ],
      "description": "OR: set $t1 to ($t2 bitwise-OR 16-bit unsigned immediate)"
    },
    {
      "pattern": "or $t1,100",
      "replacement": [
        "ori RG1, RG1, VL2U"
      ],
      "description": "OR: set $t1 to ($t1 bitwise-OR 16-bit unsigned immediate)"
    }
  ],
  "xor": [
    {
      "pattern": "xor $t1,$t2,100",
      "replacement": [
        "xori RG1, RG2, VL3U"
      ],
      "description": "XOR: set $t1 to ($t2 bitwise-exclusive-OR 16-bit unsigned immediate)"
    },
    {
      "pattern": "xor $t1,100",
      "replacement": [
        "xori RG1, RG1, VL2U"
      ],
      "description": "XOR: set $t1 to ($t1 bitwise-exclusive-OR 16-bit unsigned immediate)"
    }
  ],
  "xori": [
    {
      "pattern": "xori $t1,100000",
      "replacement": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "xor RG1, RG1, $1"
      ],
      "description": "XOR Immediate: set $t1 to ($t1 bitwise-exclusive-OR 32-bit immediate)"
    }
  ],
  "andi": [
    {
      "pattern": "andi $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "and RG1, RG2, $1"
      ],
      "description": "AND Immediate: set $t1 to ($t2 bitwise-AND 32-bit immediate)"
    },
    {
      "pattern": "andi $t1,100",
      "replacement": [
        "andi RG1, RG1, VL2U"
      ],
      "description": "AND Immediate: set $t1 to ($t1 bitwise-AND 16-bit unsigned immediate)"
    },
    {
      "pattern": "andi $t1,100000",
      "replacement": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "and RG1, RG1, $1"
      ],
      "description": "AND Immediate: set $t1 to ($t1 bitwise-AND 32-bit immediate)"
    }
  ],
  "ori": [
    {
      "pattern": "ori $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "or RG1, RG2, $1",
        ""
      ],
      "description": "OR Immediate: set $t1 to ($t2 bitwise-OR 32-bit immediate)"
    },
    {
      "pattern": "ori $t1,100",
      "replacement": [
        "ori RG1, RG1, VL2U"
      ],
      "description": "OR Immediate: set $t1 to ($t1 bitwise-OR 16-bit unsigned immediate)"
    },
    {
      "pattern": "ori $t1,100000",
      "replacement": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "or RG1, RG1, $1"
      ],
      "description": "OR Immediate: set $t1 to ($t1 bitwise-OR 32-bit immediate)"
    }
  ],
  "seq": [
    {
      "pattern": "seq $t1,$t2,$t3",
      "replacement": [
        "subu RG1, RG2, RG3",
        "ori $1, $0, 1",
        "sltu RG1, RG1, $1"
      ],
      "description": "Set EQual: if $t2 equal to $t3 then set $t1 to 1 else 0"
    },
    {
      "pattern": "seq $t1,$t2,-100",
      "replacement": [
        "addi $1, $0, VL3",
        "subu RG1, RG2, $1",
        "ori $1, $0, 1",
        "sltu RG1, RG1, $1"
      ],
      "description": "Set EQual: if $t2 equal to 16-bit immediate then set $t1 to 1 else 0"
    },
    {
      "pattern": "seq $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "subu RG1, RG2, $1",
        "ori $1, $0, 1",
        "sltu RG1, RG1, $1"
      ],
      "description": "Set EQual: if $t2 equal to 32-bit immediate then set $t1 to 1 else 0"
    }
  ],
  "sne": [
    {
      "pattern": "sne $t1,$t2,$t3",
      "replacement": [
        "subu RG1, RG2, RG3",
        "sltu RG1, $0, RG1"
      ],
      "description": "Set Not Equal: if $t2 not equal to $t3 then set $t1 to 1 else 0"
    },
    {
      "pattern": "sne $t1,$t2,-100",
      "replacement": [
        "addi $1, $0, VL3",
        "subu RG1, RG2, $1",
        "sltu RG1, $0, RG1"
      ],
      "description": "Set Not Equal: if $t2 not equal to 16-bit immediate then set $t1 to 1 else 0"
    },
    {
      "pattern": "sne $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "subu RG1, RG2, $1",
        "sltu RG1, $0, RG1"
      ],
      "description": "Set Not Equal: if $t2 not equal to 32-bit immediate then set $t1 to 1 else 0"
    }
  ],
  "sge": [
    {
      "pattern": "sge $t1,$t2,$t3",
      "replacement": [
        "slt RG1, RG2, RG3",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ],
      "description": "Set Greater or Equal: if $t2 greater or equal to $t3 then set $t1 to 1 else 0"
    },
    {
      "pattern": "sge $t1,$t2,-100",
      "replacement": [
        "addi $1, $0, VL3",
        "slt RG1, RG2, $1",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ],
      "description": "Set Greater or Equal: if $t2 greater or equal to 16-bit immediate then set $t1 to 1 else 0"
    },
    {
      "pattern": "sge $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "slt RG1, RG2, $1",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ],
      "description": "Set Greater or Equal: if $t2 greater or equal to 32-bit immediate then set $t1 to 1 else 0"
    }
  ],
  "sgeu": [
    {
      "pattern": "sgeu $t1,$t2,$t3",
      "replacement": [
        "sltu RG1, RG2, RG3",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ],
      "description": "Set Greater or Equal Unsigned: if $t2 greater or equal to $t3 (unsigned compare) then set $t1 to 1 else 0"
    },
    {
      "pattern": "sgeu $t1,$t2,-100",
      "replacement": [
        "addi $1, $0, VL3",
        "sltu RG1, RG2, $1",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ],
      "description": "Set Greater or Equal Unsigned: if $t2 greater or equal to 16-bit immediate (unsigned compare) then set $t1 to 1 else 0"
    },
    {
      "pattern": "sgeu $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "sltu RG1, RG2, $1",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ],
      "description": "Set Greater or Equal Unsigned: if $t2 greater or equal to 32-bit immediate (unsigned compare) then set $t1 to 1 else 0"
    }
  ],
  "sgt": [
    {
      "pattern": "sgt $t1,$t2,$t3",
      "replacement": [
        "slt RG1, RG3, RG2"
      ],
      "description": "Set Greater Than: if $t2 greater than $t3 then set $t1 to 1 else 0"
    },
    {
      "pattern": "sgt $t1,$t2,-100",
      "replacement": [
        "addi $1, $0, VL3",
        "slt RG1, $1, RG2"
      ],
      "description": "Set Greater Than: if $t2 greater than 16-bit immediate then set $t1 to 1 else 0"
    },
    {
      "pattern": "sgt $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "slt RG1, $1, RG2"
      ],
      "description": "Set Greater Than: if $t2 greater than 32-bit immediate then set $t1 to 1 else 0"
    }
  ],
  "sgtu": [
    {
      "pattern": "sgtu $t1,$t2,$t3",
      "replacement": [
        "sltu RG1, RG3, RG2"
      ],
      "description": "Set Greater Than Unsigned: if $t2 greater than $t3 (unsigned compare) then set $t1 to 1 else 0"
    },
    {
      "pattern": "sgtu $t1,$t2,-100",
      "replacement": [
        "addi $1, $0, VL3",
        "sltu RG1, $1, RG2"
      ],
      "description": "Set Greater Than Unsigned: if $t2 greater than 16-bit immediate (unsigned compare) then set $t1 to 1 else 0"
    },
    {
      "pattern": "sgtu $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "sltu RG1, $1, RG2"
      ],
      "description": "Set Greater Than Unsigned: if $t2 greater than 32-bit immediate (unsigned compare) then set $t1 to 1 else 0"
    }
  ],
  "sle": [
    {
      "pattern": "sle $t1,$t2,$t3",
      "replacement": [
        "slt RG1, RG3, RG2",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ],
      "description": "Set Less or Equal: if $t2 less or equal to $t3 then set $t1 to 1 else 0"
    },
    {
      "pattern": "sle $t1,$t2,-100",
      "replacement": [
        "addi $1, $0, VL3",
        "slt RG1, $1, RG2",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ],
      "description": "Set Less or Equal: if $t2 less or equal to 16-bit immediate then set $t1 to 1 else 0"
    },
    {
      "pattern": "sle $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "slt RG1, $1, RG2",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ],
      "description": "Set Less or Equal: if $t2 less or equal to 32-bit immediate then set $t1 to 1 else 0"
    }
  ],
  "sleu": [
    {
      "pattern": "sleu $t1,$t2,$t3",
      "replacement": [
        "sltu RG1, RG3, RG2",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ],
      "description": "Set Less or Equal Unsigned: if $t2 less or equal to $t3 (unsigned compare) then set $t1 to 1 else 0"
    },
    {
      "pattern": "sleu $t1,$t2,-100",
      "replacement": [
        "addi $1, $0, VL3",
        "sltu RG1, $1, RG2",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ],
      "description": "Set Less or Equal Unsigned: if $t2 less or equal to 16-bit immediate (unsigned compare) then set $t1 to 1 else 0"
    },
    {
      "pattern": "sleu $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "sltu RG1, $1, RG2",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ],
      "description": "Set Less or Equal Unsigned: if $t2 less or equal to 32-bit immediate (unsigned compare) then set $t1 to 1 else 0"
    }
  ],
  "move": [
    {
      "pattern": "move $t1,$t2",
      "replacement": [
        "addu RG1, $0, RG2"
      ],
      "description": "MOVE: Set $t1 to contents of $t2"
    }
  ],
  "abs": [
    {
      "pattern": "abs $t1,$t2",
      "replacement": [
        "sra $1, RG2, 31",
        "xor RG1, $1, RG2",
        "subu RG1, RG1, $1"
      ],
      "description": "ABSolute value: Set $t1 to absolute value of $t2 (algorithm from Hacker's Delight) "
    }
  ],
  "neg": [
    {
      "pattern": "neg $t1,$t2",
      "replacement": [
        "sub RG1, $0, RG2"
      ],
      "description": "NEGate: Set $t1 to negation of $t2"
    }
  ],
  "negu": [
    {
      "pattern": "negu $t1,$t2",
      "replacement": [
        "subu RG1, $0, RG2"
      ],
      "description": "NEGate Unsigned: Set $t1 to negation of $t2, no overflow"
    }
  ],
  "b": [
    {
      "pattern": "b label",
      "replacement": [
        "bgez $0, LAB"
      ],
      "description": "Branch: Branch to statement at label unconditionally"
    }
  ],
  "beqz": [
    {
      "pattern": "beqz $t1,label",
      "replacement": [
        "beq RG1, $0, LAB"
      ],
      "description": "Branch if EQual Zero: Branch to statement at label if $t1 is equal to zero"
    },
    {
      "pattern": "bnez $t1,label",
      "replacement": [
        "bne RG1, $0, LAB"
      ],
      "description": "Branch if Not Equal Zero: Branch to statement at label if $t1 is not equal to zero"
    }
  ],
  "beq": [
    {
      "pattern": "beq $t1,-100,label",
      "replacement": [
        "addi $1, $0, VL2",
        "beq $1, RG1, LAB"
      ],
      "description": "Branch if EQual: Branch to statement at label if $t1 is equal to 16-bit immediate"
    },
    {
      "pattern": "beq $t1,100000,label",
      "replacement": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "beq $1, RG1, LAB"
      ],
      "description": "Branch if EQual: Branch to statement at label if $t1 is equal to 32-bit immediate"
    },
    {
      "pattern": "bne $t1,-100,label",
      "replacement": [
        "addi $1, $0, VL2",
        "bne $1, RG1, LAB"
      ],
      "description": "Branch if Not Equal: Branch to statement at label if $t1 is not equal to 16-bit immediate"
    },
    {
      "pattern": "bne $t1,100000,label",
      "replacement": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "bne $1, RG1, LAB"
      ],
      "description": "Branch if Not Equal: Branch to statement at label if $t1 is not equal to 32-bit immediate"
    }
  ],
  "bge": [
    {
      "pattern": "bge $t1,$t2,label",
      "replacement": [
        "slt $1, RG1, RG2",
        "beq $1, $0, LAB"
      ],
      "description": "Branch if Greater or Equal: Branch to statement at label if $t1 is greater or equal to $t2"
    },
    {
      "pattern": "bge $t1,-100,label",
      "replacement": [
        "slti $1, RG1, VL2",
        "beq $1, $0, LAB"
      ],
      "description": "Branch if Greater or Equal: Branch to statement at label if $t1 is greater or equal to 16-bit immediate"
    },
    {
      "pattern": "bge $t1,100000,label",
      "replacement": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "slt $1, RG1, $1",
        "beq $1, $0, LAB"
      ],
      "description": "Branch if Greater or Equal: Branch to statement at label if $t1 is greater or equal to 32-bit immediate"
    }
  ],
  "bgeu": [
    {
      "pattern": "bgeu $t1,$t2,label",
      "replacement": [
        "sltu $1, RG1, RG2",
        "beq $1, $0, LAB"
      ],
      "description": "Branch if Greater or Equal Unsigned: Branch to statement at label if $t1 is greater or equal to $t2 (unsigned compare)"
    },
    {
      "pattern": "bgeu $t1,-100,label",
      "replacement": [
        "sltiu $1, RG1, VL2",
        "beq $1, $0, LAB"
      ],
      "description": "Branch if Greater or Equal Unsigned: Branch to statement at label if $t1 is greater or equal to 16-bit immediate (unsigned compare)"
    },
    {
      "pattern": "bgeu $t1,100000,label",
      "replacement": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "sltu $1, RG1, $1",
        "beq $1, $0, LAB"
      ],
      "description": "Branch if Greater or Equal Unsigned: Branch to statement at label if $t1 is greater or equal to 32-bit immediate (unsigned compare)"
    }
  ],
  "bgt": [
    {
      "pattern": "bgt $t1,$t2,label",
      "replacement": [
        "slt $1, RG2, RG1",
        "bne $1, $0, LAB"
      ],
      "description": "Branch if Greater Than: Branch to statement at label if $t1 is greater than $t2"
    },
    {
      "pattern": "bgt $t1,-100,label",
      "replacement": [
        "addi $1, $0, VL2",
        "slt $1, $1, RG1",
        "bne $1, $0, LAB"
      ],
      "description": "Branch if Greater Than: Branch to statement at label if $t1 is greater than 16-bit immediate"
    },
    {
      "pattern": "bgt $t1,100000,label",
      "replacement": [
        "lui $1, VHL2P1",
        "ori $1, $1, VL2P1U",
        "slt $1, RG1, $1",
        "beq $1, $0, LAB"
      ],
      "description": "Branch if Greater Than: Branch to statement at label if $t1 is greater than 32-bit immediate"
    }
  ],
  "bgtu": [
    {
      "pattern": "bgtu $t1,$t2,label",
      "replacement": [
        "sltu $1, RG2, RG1",
        "bne $1, $0, LAB"
      ],
      "description": "Branch if Greater Than Unsigned: Branch to statement at label if $t1 is greater than $t2 (unsigned compare)"
    },
    {
      "pattern": "bgtu $t1,-100,label",
      "replacement": [
        "addi $1, $0, VL2",
        "sltu $1, $1, RG1",
        "bne $1, $0, LAB"
      ],
      "description": "Branch if Greater Than Unsigned: Branch to statement at label if $t1 is greater than 16-bit immediate (unsigned compare)"
    },
    {
      "pattern": "bgtu $t1,100000,label",
      "replacement": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "sltu $1, $1, RG1",
        "bne $1, $0, LAB"
      ],
      "description": "Branch if Greater Than Unsigned: Branch to statement at label if $t1 is greater than 16-bit immediate (unsigned compare)"
    }
  ],
  "ble": [
    {
      "pattern": "ble $t1,$t2,label",
      "replacement": [
        "slt $1, RG2, RG1",
        "beq $1, $0, LAB"
      ],
      "description": "Branch if Less or Equal: Branch to statement at label if $t1 is less than or equal to $t2"
    },
    {
      "pattern": "ble $t1,-100,label",
      "replacement": [
        "addi $1, RG1, -1",
        "slti $1, $1, VL2",
        "bne $1, $0, LAB"
      ],
      "description": "Branch if Less or Equal: Branch to statement at label if $t1 is less than or equal to 16-bit immediate"
    },
    {
      "pattern": "ble $t1,100000,label",
      "replacement": [
        "lui $1, VHL2P1",
        "ori $1, $1, VL2P1U",
        "slt $1, RG1, $1",
        "bne $1, $0, LAB"
      ],
      "description": "Branch if Less or Equal: Branch to statement at label if $t1 is less than or equal to 32-bit immediate"
    }
  ],
  "bleu": [
    {
      "pattern": "bleu $t1,$t2,label",
      "replacement": [
        "sltu $1, RG2, RG1",
        "beq $1, $0, LAB"
      ],
      "description": "Branch if Less or Equal Unsigned: Branch to statement at label if $t1 is less than or equal to $t2 (unsigned compare)"
    },
    {
      "pattern": "bleu $t1,-100,label",
      "replacement": [
        "addi $1, $0, VL2",
        "sltu $1, $1, RG1",
        "beq $1, $0, LAB"
      ],
      "description": "Branch if Less or Equal Unsigned: Branch to statement at label if $t1 is less than or equal to 16-bit immediate (unsigned compare)"
    },
    {
      "pattern": "bleu $t1,100000,label",
      "replacement": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "sltu $1, $1, RG1",
        "beq $1, $0, LAB"
      ],
      "description": "Branch if Less or Equal Unsigned: Branch to statement at label if $t1 is less than or equal to 32-bit immediate (unsigned compare)"
    }
  ],
  "blt": [
    {
      "pattern": "blt $t1,$t2,label",
      "replacement": [
        "slt $1, RG1, RG2",
        "bne $1, $0, LAB"
      ],
      "description": "Branch if Less Than: Branch to statement at label if $t1 is less than $t2"
    },
    {
      "pattern": "blt $t1,-100,label",
      "replacement": [
        "slti $1, RG1, VL2",
        "bne $1, $0, LAB"
      ],
      "description": "Branch if Less Than: Branch to statement at label if $t1 is less than 16-bit immediate"
    },
    {
      "pattern": "blt $t1,100000,label",
      "replacement": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "slt $1, RG1, $1",
        "bne $1, $0, LAB"
      ],
      "description": "Branch if Less Than: Branch to statement at label if $t1 is less than 32-bit immediate"
    }
  ],
  "bltu": [
    {
      "pattern": "bltu $t1,$t2,label",
      "replacement": [
        "sltu $1, RG1, RG2",
        "bne $1, $0, LAB"
      ],
      "description": "Branch if Less Than Unsigned: Branch to statement at label if $t1 is less than $t2"
    },
    {
      "pattern": "bltu $t1,-100,label",
      "replacement": [
        "sltiu $1, RG1, VL2",
        "bne $1, $0, LAB"
      ],
      "description": "Branch if Less Than Unsigned: Branch to statement at label if $t1 is less than 16-bit immediate"
    },
    {
      "pattern": "bltu $t1,100000,label",
      "replacement": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "sltu $1, RG1, $1",
        "bne $1, $0, LAB"
      ],
      "description": "Branch if Less Than Unsigned: Branch to statement at label if $t1 is less than 32-bit immediate"
    }
  ],
  "rol": [
    {
      "pattern": "rol $t1,$t2,$t3",
      "replacement": [
        "subu $1, $0, RG3",
        "srlv $1, RG2, $1",
        "sllv RG1, RG2, RG3",
        "or RG1, RG1, $1"
      ],
      "description": "ROtate Left: Set $t1 to ($t2 rotated left by number of bit positions specified in $t3)"
    },
    {
      "pattern": "rol $t1,$t2,10",
      "replacement": [
        "srl $1, RG2, S32",
        "sll RG1, RG2, OP3",
        "or RG1, RG1, $1"
      ],
      "description": "ROtate Left: Set $t1 to ($t2 rotated left by number of bit positions specified in 5-bit immediate)"
    },
    {
      "pattern": "ror $t1,$t2,$t3",
      "replacement": [
        "subu $1, $0, RG3",
        "sllv $1, RG2, $1",
        "srlv RG1, RG2, RG3",
        "or RG1, RG1, $1"
      ],
      "description": "ROtate Right: Set $t1 to ($t2 rotated right by number of bit positions specified in $t3)"
    },
    {
      "pattern": "ror $t1,$t2,10",
      "replacement": [
        "sll $1, RG2, S32",
        "srl RG1, RG2, OP3",
        "or RG1, RG1, $1"
      ],
      "description": "ROtate Right: Set $t1 to ($t2 rotated right by number of bit positions specified in 5-bit immediate)"
    }
  ],
  "mfc1.d": [
    {
      "pattern": "mfc1.d $t1,$f2",
      "replacement": [
        "mfc1 RG1, RG2",
        "mfc1 NR1, NR2"
      ],
      "description": "Move From Coprocessor 1 Double: Set $t1 to contents of $f2, set next higher register from $t1 to contents of next higher register from $f2"
    },
    {
      "pattern": "mtc1.d $t1,$f2",
      "replacement": [
        "mtc1 RG1, RG2",
        "mtc1 NR1, NR2"
      ],
      "description": "Move To Coprocessor 1 Double: Set $f2 to contents of $t1, set next higher register from $f2 to contents of next higher register from $t1"
    }
  ],
  "mul": [
    {
      "pattern": "mul $t1,$t2,-100",
      "replacement": [
        "addi $1, $0, VL3",
        "mul RG1, RG2, $1"
      ],
      "description": "MULtiplication: Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of the product of $t2 and 16-bit signed immediate (use mfhi to access HI, mflo to access LO)"
    },
    {
      "pattern": "mul $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "mul RG1, RG2, $1"
      ],
      "description": "MULtiplication: Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of the product of $t2 and 32-bit immediate (use mfhi to access HI, mflo to access LO)"
    }
  ],
  "mulu": [
    {
      "pattern": "mulu $t1,$t2,$t3",
      "replacement": [
        "multu RG2, RG3",
        "mflo RG1"
      ],
      "description": "MULtiplication Unsigned: Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of ($t2 multiplied by $t3, unsigned multiplication)"
    },
    {
      "pattern": "mulu $t1,$t2,-100",
      "replacement": [
        "addi $1, $0, VL3",
        "multu RG2, $1",
        "mflo RG1"
      ],
      "description": "MULtiplication Unsigned:  Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of ($t2 multiplied by 16-bit immediate, unsigned multiplication)"
    },
    {
      "pattern": "mulu $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "multu RG2, $1",
        "mflo RG1"
      ],
      "description": "MULtiplication Unsigned:  Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of ($t2 multiplied by 32-bit immediate, unsigned multiplication)"
    }
  ],
  "mulo": [
    {
      "pattern": "mulo $t1,$t2,$t3",
      "replacement": [
        "mult RG2, RG3",
        "mfhi $1",
        "mflo RG1",
        "sra RG1, RG1, 31",
        "beq $1, RG1, BROFF12",
        "DBNOP",
        "break",
        "mflo RG1"
      ],
      "description": "MULtiplication with Overflow: Set $t1 to low-order 32 bits of the product of $t2 and $t3"
    },
    {
      "pattern": "mulo $t1,$t2,-100",
      "replacement": [
        "addi $1, $0, VL3",
        "mult RG2, $1",
        "mfhi $1",
        "mflo RG1",
        "sra RG1, RG1, 31",
        "beq $1, RG1, BROFF12",
        "DBNOP",
        "break",
        "mflo RG1"
      ],
      "description": "MULtiplication with Overflow: Set $t1 to low-order 32 bits of the product of $t2 and signed 16-bit immediate"
    },
    {
      "pattern": "mulo $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "mult RG2, $1",
        "mfhi $1",
        "mflo RG1",
        "sra RG1, RG1, 31",
        "beq $1, RG1, BROFF12",
        "DBNOP",
        "break",
        "mflo RG1"
      ],
      "description": "MULtiplication with Overflow: Set $t1 to low-order 32 bits of the product of $t2 and 32-bit immediate"
    }
  ],
  "mulou": [
    {
      "pattern": "mulou $t1,$t2,$t3",
      "replacement": [
        "multu RG2, RG3",
        "mfhi $1",
        "beq $1,$0, BROFF12",
        "DBNOP",
        "break",
        "mflo RG1"
      ],
      "description": "MULtiplication with Overflow Unsigned: Set $t1 to low-order 32 bits of the product of $t2 and $t3"
    },
    {
      "pattern": "mulou $t1,$t2,-100",
      "replacement": [
        "addi $1, $0, VL3",
        "multu RG2, $1",
        "mfhi $1",
        "beq $1,$0, BROFF12",
        "DBNOP",
        "break",
        "mflo RG1"
      ],
      "description": "MULtiplication with Overflow Unsigned: Set $t1 to low-order 32 bits of the product of $t2 and signed 16-bit immediate"
    },
    {
      "pattern": "mulou $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "multu RG2, $1",
        "mfhi $1",
        "beq $1,$0, BROFF12",
        "DBNOP",
        "break",
        "mflo RG1"
      ],
      "description": "MULtiplication with Overflow Unsigned: Set $t1 to low-order 32 bits of the product of $t2 and 32-bit immediate"
    }
  ],
  "div": [
    {
      "pattern": "div $t1,$t2,$t3",
      "replacement": [
        "bne RG3, $0, BROFF12",
        "DBNOP",
        "break",
        "div RG2, RG3",
        "mflo RG1"
      ],
      "description": "DIVision: Set $t1 to ($t2 divided by $t3, integer division)"
    },
    {
      "pattern": "div $t1,$t2,-100",
      "replacement": [
        "addi $1, $0, VL3",
        "div RG2, $1",
        "mflo RG1"
      ],
      "description": "DIVision: Set $t1 to ($t2 divided by 16-bit immediate, integer division)"
    },
    {
      "pattern": "div $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "div RG2, $1",
        "mflo RG1"
      ],
      "description": "DIVision: Set $t1 to ($t2 divided by 32-bit immediate, integer division)"
    }
  ],
  "divu": [
    {
      "pattern": "divu $t1,$t2,$t3",
      "replacement": [
        "bne RG3, $0, BROFF12",
        "DBNOP",
        "break",
        "divu RG2, RG3",
        "mflo RG1"
      ],
      "description": "DIVision Unsigned:  Set $t1 to ($t2 divided by $t3, unsigned integer division)"
    },
    {
      "pattern": "divu $t1,$t2,-100",
      "replacement": [
        "addi $1, $0, VL3",
        "divu RG2, $1",
        "mflo RG1"
      ],
      "description": "DIVision Unsigned:  Set $t1 to ($t2 divided by 16-bit immediate, unsigned integer division)"
    },
    {
      "pattern": "divu $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "divu RG2, $1",
        "mflo RG1"
      ],
      "description": "DIVision Unsigned:  Set $t1 to ($t2 divided by 32-bit immediate, unsigned integer division)"
    }
  ],
  "rem": [
    {
      "pattern": "rem $t1,$t2,$t3",
      "replacement": [
        "bne RG3, $0, BROFF12",
        "DBNOP",
        "break",
        "div RG2, RG3",
        "mfhi RG1"
      ],
      "description": "REMainder: Set $t1 to (remainder of $t2 divided by $t3)"
    },
    {
      "pattern": "rem $t1,$t2,-100",
      "replacement": [
        "addi $1, $0, VL3",
        "div RG2, $1",
        "mfhi RG1"
      ],
      "description": "REMainder: Set $t1 to (remainder of $t2 divided by 16-bit immediate)"
    },
    {
      "pattern": "rem $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "div RG2, $1",
        "mfhi RG1"
      ],
      "description": "REMainder: Set $t1 to (remainder of $t2 divided by 32-bit immediate)"
    }
  ],
  "remu": [
    {
      "pattern": "remu $t1,$t2,$t3",
      "replacement": [
        "bne RG3, $0, BROFF12",
        "DBNOP",
        "break",
        "divu RG2, RG3",
        "mfhi RG1"
      ],
      "description": "REMainder: Set $t1 to (remainder of $t2 divided by $t3, unsigned division)"
    },
    {
      "pattern": "remu $t1,$t2,-100",
      "replacement": [
        "addi $1, $0, VL3",
        "divu RG2, $1",
        "mfhi RG1"
      ],
      "description": "REMainder: Set $t1 to (remainder of $t2 divided by 16-bit immediate, unsigned division)"
    },
    {
      "pattern": "remu $t1,$t2,100000",
      "replacement": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "divu RG2, $1",
        "mfhi RG1"
      ],
      "description": "REMainder: Set $t1 to (remainder of $t2 divided by 32-bit immediate, unsigned division)"
    }
  ],
  "li": [
    {
      "pattern": "li $t1,-100",
      "replacement": [
        "addiu RG1, $0, VL2"
      ],
      "description": "Load Immediate: Set $t1 to 16-bit immediate (sign-extended)"
    },
    {
      "pattern": "li $t1,100",
      "replacement": [
        "ori RG1, $0, VL2U"
      ],
      "description": "Load Immediate: Set $t1 to unsigned 16-bit immediate (zero-extended)"
    },
    {
      "pattern": "li $t1,100000",
      "replacement": [
        "lui $1, VHL2",
        "ori RG1, $1, VL2U"
      ],
      "description": "Load Immediate: Set $t1 to 32-bit immediate"
    }
  ],
  "la": [
    {
      "pattern": "la $t1,($t2)",
      "replacement": [
        "addi RG1, RG3, 0"
      ],
      "description": "Load Address: Set $t1 to contents of $t2"
    },
    {
      "pattern": "la $t1,-100",
      "replacement": [
        "addiu RG1, $0, VL2"
      ],
      "description": "Load Address: Set $t1 to 16-bit immediate (sign-extended) "
    },
    {
      "pattern": "la $t1,100",
      "replacement": [
        "ori RG1, $0, VL2U"
      ],
      "description": "Load Address: Set $t1 to 16-bit immediate (zero-extended) "
    },
    {
      "pattern": "la $t1,100000",
      "replacement": [
        "lui $1, VHL2",
        "ori RG1, $1, VL2U"
      ],
      "description": "Load Address: Set $t1 to 32-bit immediate"
    },
    {
      "pattern": "la $t1,100($t2)",
      "replacement": [
        "ori $1, $0, VL2U",
        "add RG1, RG4, $1"
      ],
      "description": "Load Address: Set $t1 to sum (of $t2 and 16-bit immediate)"
    },
    {
      "pattern": "la $t1,100000($t2)",
      "replacement": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "add RG1, RG4, $1"
      ],
      "description": "Load Address: Set $t1 to sum (of $t2 and 32-bit immediate)"
    },
    {
      "pattern": "la $t1,label",
      "replacement": [
        "lui $1, LHL",
        "ori RG1, $1, LL2U",
        "COMPACT",
        "addi RG1, $0, LL2"
      ],
      "description": "Load Address: Set $t1 to label's address"
    },
    {
      "pattern": "la $t1,label($t2)",
      "replacement": [
        "lui $1, LHL",
        "ori $1, $1, LL2U",
        "add RG1, RG4, $1",
        "COMPACT",
        "addi RG1, RG4, LL2"
      ],
      "description": "Load Address: Set $t1 to sum (of $t2 and label's address)"
    },
    {
      "pattern": "la $t1,label+100000",
      "replacement": [
        "lui $1, LHPN",
        "ori RG1, $1, LLPU"
      ],
      "description": "Load Address: Set $t1 to sum (of label's address and 32-bit immediate)"
    },
    {
      "pattern": "la $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPN",
        "ori $1, $1, LLPU",
        "add RG1, RG6, $1"
      ],
      "description": "Load Address: Set $t1 to sum (of label's address, 32-bit immediate, and $t2)"
    }
  ],
  "lw": [
    {
      "pattern": "lw $t1,($t2)",
      "replacement": [
        "lw RG1,0(RG3)"
      ],
      "description": "Load Word: Set $t1 to contents of effective memory word address"
    },
    {
      "pattern": "lw $t1,-100",
      "replacement": [
        "lw RG1, VL2($0)"
      ],
      "description": "Load Word: Set $t1 to contents of effective memory word address"
    },
    {
      "pattern": "lw $t1,100",
      "replacement": [
        "ori $1, $0, VL2U",
        "lw RG1, 0($1)"
      ],
      "description": "Load Word: Set $t1 to contents of effective memory word address"
    },
    {
      "pattern": "lw $t1,100000",
      "replacement": [
        "lui $1, VH2",
        "lw RG1,VL2($1)"
      ],
      "description": "Load Word: Set $t1 to contents of effective memory word address"
    },
    {
      "pattern": "lw $t1,100($t2)",
      "replacement": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "lw RG1, 0($1)"
      ],
      "description": "Load Word: Set $t1 to contents of effective memory word address"
    },
    {
      "pattern": "lw $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lw RG1, VL2($1)"
      ],
      "description": "Load Word: Set $t1 to contents of effective memory word address"
    },
    {
      "pattern": "lw $t1,label",
      "replacement": [
        "lui $1, LH2",
        "lw RG1, LL2($1)",
        "COMPACT",
        "lw RG1, LL2($0)"
      ],
      "description": "Load Word: Set $t1 to contents of memory word at label's address"
    },
    {
      "pattern": "lw $t1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lw RG1, LL2($1)",
        "COMPACT",
        "lw RG1, LL2(RG4)"
      ],
      "description": "Load Word: Set $t1 to contents of effective memory word address"
    },
    {
      "pattern": "lw $t1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "lw RG1, LLP($1)"
      ],
      "description": "Load Word: Set $t1 to contents of effective memory word address "
    },
    {
      "pattern": "lw $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lw RG1, LLP($1)"
      ],
      "description": "Load Word: Set $t1 to contents of effective memory word address"
    }
  ],
  "sw": [
    {
      "pattern": "sw $t1,($t2)",
      "replacement": [
        "sw RG1,0(RG3)"
      ],
      "description": "Store Word: Store $t1 contents into effective memory word address"
    },
    {
      "pattern": "sw $t1,-100",
      "replacement": [
        "sw RG1, VL2($0)"
      ],
      "description": "Store Word: Store $t1 contents into effective memory word address"
    },
    {
      "pattern": "sw $t1,100",
      "replacement": [
        "ori $1, $0, VL2U",
        "sw RG1, 0($1)"
      ],
      "description": "Store Word: Store $t1 contents into effective memory word address"
    },
    {
      "pattern": "sw $t1,100000",
      "replacement": [
        "lui $1, VH2",
        "sw RG1,VL2($1)"
      ],
      "description": "Store Word: Store $t1 contents into effective memory word address"
    },
    {
      "pattern": "sw $t1,100($t2)",
      "replacement": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "sw RG1, 0($1)"
      ],
      "description": "Store Word: Store $t1 contents into effective memory word address"
    },
    {
      "pattern": "sw $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "sw RG1, VL2($1)"
      ],
      "description": "Store Word: Store $t1 contents into effective memory word address"
    },
    {
      "pattern": "sw $t1,label",
      "replacement": [
        "lui $1, LH2",
        "sw RG1, LL2($1)",
        "COMPACT",
        "sw RG1, LL2($0)"
      ],
      "description": "Store Word: Store $t1 contents into memory word at label's address"
    },
    {
      "pattern": "sw $t1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "sw RG1, LL2($1)",
        "COMPACT",
        "sw RG1, LL2(RG4)"
      ],
      "description": "Store Word: Store $t1 contents into effective memory word address"
    },
    {
      "pattern": "sw $t1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "sw RG1, LLP($1)"
      ],
      "description": "Store Word: Store $t1 contents into effective memory word address"
    },
    {
      "pattern": "sw $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "sw RG1, LLP($1)"
      ],
      "description": "Store Word: Store $t1 contents into effective memory word address"
    }
  ],
  "lh": [
    {
      "pattern": "lh $t1,($t2)",
      "replacement": [
        "lh RG1,0(RG3)"
      ],
      "description": "Load Halfword: Set $t1 to sign-extended 16-bit value from effective memory halfword address"
    },
    {
      "pattern": "lh $t1,-100",
      "replacement": [
        "lh RG1, VL2($0)"
      ],
      "description": "Load Halfword: Set $t1 to sign-extended 16-bit value from effective memory halfword address"
    },
    {
      "pattern": "lh $t1,100",
      "replacement": [
        "ori $1, $0, VL2U",
        "lh RG1, 0($1)"
      ],
      "description": "Load Halfword: Set $t1 to sign-extended 16-bit value from effective memory halfword address"
    },
    {
      "pattern": "lh $t1,100000",
      "replacement": [
        "lui $1, VH2",
        "lh RG1,VL2($1)"
      ],
      "description": "Load Halfword: Set $t1 to sign-extended 16-bit value from effective memory halfword address"
    },
    {
      "pattern": "lh $t1,100($t2)",
      "replacement": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "lh RG1, 0($1)"
      ],
      "description": "Load Halfword: Set $t1 to sign-extended 16-bit value from effective memory halfword address"
    },
    {
      "pattern": "lh $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lh RG1, VL2($1)"
      ],
      "description": "Load Halfword: Set $t1 to sign-extended 16-bit value from effective memory halfword address"
    },
    {
      "pattern": "lh $t1,label",
      "replacement": [
        "lui $1, LH2",
        "lh RG1, LL2($1)",
        "COMPACT",
        "lh RG1, LL2($0)"
      ],
      "description": "Load Halfword: Set $t1 to sign-extended 16-bit value from effective memory halfword address"
    },
    {
      "pattern": "lh $t1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lh RG1, LL2($1)",
        "COMPACT",
        "lh RG1, LL2(RG4)"
      ],
      "description": "Load Halfword: Set $t1 to sign-extended 16-bit value from effective memory halfword address"
    },
    {
      "pattern": "lh $t1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "lh RG1, LLP($1)"
      ],
      "description": "Load Halfword: Set $t1 to sign-extended 16-bit value from effective memory halfword address"
    },
    {
      "pattern": "lh $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lh RG1, LLP($1)"
      ],
      "description": "Load Halfword: Set $t1 to sign-extended 16-bit value from effective memory halfword address"
    }
  ],
  "sh": [
    {
      "pattern": "sh $t1,($t2)",
      "replacement": [
        "sh RG1,0(RG3)"
      ],
      "description": "Store Halfword: Store the low-order 16 bits of $t1 into the effective memory halfword address"
    },
    {
      "pattern": "sh $t1,-100",
      "replacement": [
        "sh RG1, VL2($0)"
      ],
      "description": "Store Halfword: Store the low-order 16 bits of $t1 into the effective memory halfword address"
    },
    {
      "pattern": "sh $t1,100",
      "replacement": [
        "ori $1, $0, VL2U",
        "sh RG1, 0($1)"
      ],
      "description": "Store Halfword: Store the low-order 16 bits of $t1 into the effective memory halfword address"
    },
    {
      "pattern": "sh $t1,100000",
      "replacement": [
        "lui $1, VH2",
        "sh RG1,VL2($1)"
      ],
      "description": "Store Halfword: Store the low-order 16 bits of $t1 into the effective memory halfword address"
    },
    {
      "pattern": "sh $t1,100($t2)",
      "replacement": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "sh RG1, 0($1)"
      ],
      "description": "Store Halfword: Store the low-order 16 bits of $t1 into the effective memory halfword address"
    },
    {
      "pattern": "sh $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "sh RG1, VL2($1)"
      ],
      "description": "Store Halfword: Store the low-order 16 bits of $t1 into the effective memory halfword address"
    },
    {
      "pattern": "sh $t1,label",
      "replacement": [
        "lui $1, LH2",
        "sh RG1, LL2($1)",
        "COMPACT",
        "sh RG1, LL2($0)"
      ],
      "description": "Store Halfword: Store the low-order 16 bits of $t1 into the effective memory halfword address"
    },
    {
      "pattern": "sh $t1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "sh RG1, LL2($1)",
        "COMPACT",
        "sh RG1, LL2(RG4)"
      ],
      "description": "Store Halfword: Store the low-order 16 bits of $t1 into the effective memory halfword address"
    },
    {
      "pattern": "sh $t1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "sh RG1, LLP($1)"
      ],
      "description": "Store Halfword: Store the low-order 16 bits of $t1 into the effective memory halfword address"
    },
    {
      "pattern": "sh $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "sh RG1, LLP($1)"
      ],
      "description": "Store Halfword: Store the low-order 16 bits of $t1 into the effective memory halfword address"
    }
  ],
  "lb": [
    {
      "pattern": "lb $t1,($t2)",
      "replacement": [
        "lb RG1,0(RG3)"
      ],
      "description": "Load Byte: Set $t1 to sign-extended 8-bit value from effective memory byte address"
    },
    {
      "pattern": "lb $t1,-100",
      "replacement": [
        "lb RG1, VL2($0)"
      ],
      "description": "Load Byte: Set $t1 to sign-extended 8-bit value from effective memory byte address"
    },
    {
      "pattern": "lb $t1,100",
      "replacement": [
        "ori $1, $0, VL2U",
        "lb RG1, 0($1)"
      ],
      "description": "Load Byte: Set $t1 to sign-extended 8-bit value from effective memory byte address"
    },
    {
      "pattern": "lb $t1,100000",
      "replacement": [
        "lui $1, VH2",
        "lb RG1,VL2($1)"
      ],
      "description": "Load Byte: Set $t1 to sign-extended 8-bit value from effective memory byte address"
    },
    {
      "pattern": "lb $t1,100($t2)",
      "replacement": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "lb RG1, 0($1)"
      ],
      "description": "Load Byte: Set $t1 to sign-extended 8-bit value from effective memory byte address"
    },
    {
      "pattern": "lb $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lb RG1, VL2($1)"
      ],
      "description": "Load Byte: Set $t1 to sign-extended 8-bit value from effective memory byte address"
    },
    {
      "pattern": "lb $t1,label",
      "replacement": [
        "lui $1, LH2",
        "lb RG1, LL2($1)",
        "COMPACT",
        "lb RG1, LL2($0)"
      ],
      "description": "Load Byte: Set $t1 to sign-extended 8-bit value from effective memory byte address"
    },
    {
      "pattern": "lb $t1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lb RG1, LL2($1)",
        "COMPACT",
        "lb RG1, LL2(RG4)"
      ],
      "description": "Load Byte: Set $t1 to sign-extended 8-bit value from effective memory byte address"
    },
    {
      "pattern": "lb $t1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "lb RG1, LLP($1)"
      ],
      "description": "Load Byte: Set $t1 to sign-extended 8-bit value from effective memory byte address"
    },
    {
      "pattern": "lb $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lb RG1, LLP($1)"
      ],
      "description": "Load Byte: Set $t1 to sign-extended 8-bit value from effective memory byte address"
    }
  ],
  "sb": [
    {
      "pattern": "sb $t1,($t2)",
      "replacement": [
        "sb RG1,0(RG3)"
      ],
      "description": "Store Byte: Store the low-order 8 bits of $t1 into the effective memory byte address"
    },
    {
      "pattern": "sb $t1,-100",
      "replacement": [
        "sb RG1, VL2($0)"
      ],
      "description": "Store Byte: Store the low-order 8 bits of $t1 into the effective memory byte address"
    },
    {
      "pattern": "sb $t1,100",
      "replacement": [
        "ori $1, $0, VL2U",
        "sb RG1, 0($1)"
      ],
      "description": "Store Byte: Store the low-order 8 bits of $t1 into the effective memory byte address"
    },
    {
      "pattern": "sb $t1,100000",
      "replacement": [
        "lui $1, VH2",
        "sb RG1,VL2($1)"
      ],
      "description": "Store Byte: Store the low-order 8 bits of $t1 into the effective memory byte address"
    },
    {
      "pattern": "sb $t1,100($t2)",
      "replacement": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "sb RG1, 0($1)"
      ],
      "description": "Store Byte: Store the low-order 8 bits of $t1 into the effective memory byte address"
    },
    {
      "pattern": "sb $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "sb RG1, VL2($1)"
      ],
      "description": "Store Byte: Store the low-order 8 bits of $t1 into the effective memory byte address"
    },
    {
      "pattern": "sb $t1,label",
      "replacement": [
        "lui $1, LH2",
        "sb RG1, LL2($1)",
        "COMPACT",
        "sb RG1, LL2($0)"
      ],
      "description": "Store Byte: Store the low-order 8 bits of $t1 into the effective memory byte address"
    },
    {
      "pattern": "sb $t1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "sb RG1, LL2($1)",
        "COMPACT",
        "sb RG1, LL2(RG4)"
      ],
      "description": "Store Byte: Store the low-order 8 bits of $t1 into the effective memory byte address"
    },
    {
      "pattern": "sb $t1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "sb RG1, LLP($1)"
      ],
      "description": "Store Byte: Store the low-order 8 bits of $t1 into the effective memory byte address"
    },
    {
      "pattern": "sb $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "sb RG1, LLP($1)"
      ],
      "description": "Store Byte: Store the low-order 8 bits of $t1 into the effective memory byte address"
    }
  ],
  "lhu": [
    {
      "pattern": "lhu $t1,($t2)",
      "replacement": [
        "lhu RG1,0(RG3)"
      ],
      "description": "Load Halfword Unsigned: Set $t1 to zero-extended 16-bit value from effective memory halfword address"
    },
    {
      "pattern": "lhu $t1,-100",
      "replacement": [
        "lhu RG1,VL2($0)"
      ],
      "description": "Load Halfword Unsigned: Set $t1 to zero-extended 16-bit value from effective memory halfword address"
    },
    {
      "pattern": "lhu $t1,100",
      "replacement": [
        "ori $1, $0, VL2U",
        "lhu RG1, 0($1)"
      ],
      "description": "Load Halfword Unsigned: Set $t1 to zero-extended 16-bit value from effective memory halfword address"
    },
    {
      "pattern": "lhu $t1,100000",
      "replacement": [
        "lui $1, VH2",
        "lhu RG1,VL2($1)"
      ],
      "description": "Load Halfword Unsigned: Set $t1 to zero-extended 16-bit value from effective memory halfword address"
    },
    {
      "pattern": "lhu $t1,100($t2)",
      "replacement": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "lhu RG1, 0($1)"
      ],
      "description": "Load Halfword Unsigned: Set $t1 to zero-extended 16-bit value from effective memory halfword address"
    },
    {
      "pattern": "lhu $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lhu RG1, VL2($1)"
      ],
      "description": "Load Halfword Unsigned: Set $t1 to zero-extended 16-bit value from effective memory halfword address"
    },
    {
      "pattern": "lhu $t1,label",
      "replacement": [
        "lui $1, LH2",
        "lhu RG1, LL2($1)",
        "COMPACT",
        "lhu RG1, LL2($0)"
      ],
      "description": "Load Halfword Unsigned: Set $t1 to zero-extended 16-bit value from effective memory halfword address"
    },
    {
      "pattern": "lhu $t1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lhu RG1, LL2($1)",
        "COMPACT",
        "lhu RG1, LL2(RG4)"
      ],
      "description": "Load Halfword Unsigned: Set $t1 to zero-extended 16-bit value from effective memory halfword address"
    },
    {
      "pattern": "lhu $t1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "lhu RG1, LLP($1)"
      ],
      "description": "Load Halfword Unsigned: Set $t1 to zero-extended 16-bit value from effective memory halfword address"
    },
    {
      "pattern": "lhu $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lhu RG1, LLP($1)"
      ],
      "description": "Load Halfword Unsigned: Set $t1 to zero-extended 16-bit value from effective memory halfword address"
    }
  ],
  "lbu": [
    {
      "pattern": "lbu $t1,($t2)",
      "replacement": [
        "lbu RG1,0(RG3)"
      ],
      "description": "Load Byte Unsigned: Set $t1 to zero-extended 8-bit value from effective memory byte address"
    },
    {
      "pattern": "lbu $t1,-100",
      "replacement": [
        "lbu RG1,VL2($0)"
      ],
      "description": "Load Byte Unsigned: Set $t1 to zero-extended 8-bit value from effective memory byte address"
    },
    {
      "pattern": "lbu $t1,100",
      "replacement": [
        "ori $1, $0, VL2U",
        "lbu RG1, 0($1)"
      ],
      "description": "Load Byte Unsigned: Set $t1 to zero-extended 8-bit value from effective memory byte address"
    },
    {
      "pattern": "lbu $t1,100000",
      "replacement": [
        "lui $1, VH2",
        "lbu RG1,VL2($1)"
      ],
      "description": "Load Byte Unsigned: Set $t1 to zero-extended 8-bit value from effective memory byte address"
    },
    {
      "pattern": "lbu $t1,100($t2)",
      "replacement": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "lbu RG1, 0($1)"
      ],
      "description": "Load Byte Unsigned: Set $t1 to zero-extended 8-bit value from effective memory byte address"
    },
    {
      "pattern": "lbu $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lbu RG1, VL2($1)"
      ],
      "description": "Load Byte Unsigned: Set $t1 to zero-extended 8-bit value from effective memory byte address"
    },
    {
      "pattern": "lbu $t1,label",
      "replacement": [
        "lui $1, LH2",
        "lbu RG1, LL2($1)",
        "COMPACT",
        "lbu RG1, LL2($0)"
      ],
      "description": "Load Byte Unsigned: Set $t1 to zero-extended 8-bit value from effective memory byte address"
    },
    {
      "pattern": "lbu $t1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lbu RG1, LL2($1)",
        "COMPACT",
        "lbu RG1, LL2(RG4)"
      ],
      "description": "Load Byte Unsigned: Set $t1 to zero-extended 8-bit value from effective memory byte address"
    },
    {
      "pattern": "lbu $t1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "lbu RG1, LLP($1)"
      ],
      "description": "Load Byte Unsigned: Set $t1 to zero-extended 8-bit value from effective memory byte address"
    },
    {
      "pattern": "lbu $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lbu RG1, LLP($1)"
      ],
      "description": "Load Byte Unsigned: Set $t1 to zero-extended 8-bit value from effective memory byte address"
    }
  ],
  "lwl": [
    {
      "pattern": "lwl $t1,($t2)",
      "replacement": [
        "lwl RG1,0(RG3)"
      ],
      "description": "Load Word Left: Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word"
    },
    {
      "pattern": "lwl $t1,-100",
      "replacement": [
        "lwl RG1,VL2($0)"
      ],
      "description": "Load Word Left: Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word"
    },
    {
      "pattern": "lwl $t1,100",
      "replacement": [
        "ori $1, $0, VL2U",
        "lwl RG1, 0($1)"
      ],
      "description": "Load Word Left: Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word"
    },
    {
      "pattern": "lwl $t1,100000",
      "replacement": [
        "lui $1, VH2",
        "lwl RG1,VL2($1)"
      ],
      "description": "Load Word Left: Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word"
    },
    {
      "pattern": "lwl $t1,100($t2)",
      "replacement": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "lwl RG1, 0($1)"
      ],
      "description": "Load Word Left: Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word"
    },
    {
      "pattern": "lwl $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lwl RG1, VL2($1)"
      ],
      "description": "Load Word Left: Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word"
    },
    {
      "pattern": "lwl $t1,label",
      "replacement": [
        "lui $1, LH2",
        "lwl RG1, LL2($1)",
        "COMPACT",
        "lwl RG1, LL2($0)"
      ],
      "description": "Load Word Left: Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word"
    },
    {
      "pattern": "lwl $t1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lwl RG1, LL2($1)",
        "COMPACT",
        "lwl RG1, LL2(RG4)"
      ],
      "description": "Load Word Left: Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word"
    },
    {
      "pattern": "lwl $t1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "lwl RG1, LLP($1)"
      ],
      "description": "Load Word Left: Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word"
    },
    {
      "pattern": "lwl $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lwl RG1, LLP($1)"
      ],
      "description": "Load Word Left: Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word"
    }
  ],
  "swl": [
    {
      "pattern": "swl $t1,($t2)",
      "replacement": [
        "swl RG1,0(RG3)"
      ],
      "description": "Store Word Left: Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word"
    },
    {
      "pattern": "swl $t1,-100",
      "replacement": [
        "swl RG1,VL2($0)"
      ],
      "description": "Store Word Left: Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word"
    },
    {
      "pattern": "swl $t1,100",
      "replacement": [
        "ori $1, $0, VL2U",
        "swl RG1, 0($1)"
      ],
      "description": "Store Word Left: Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word"
    },
    {
      "pattern": "swl $t1,100000",
      "replacement": [
        "lui $1, VH2",
        "swl RG1,VL2($1)"
      ],
      "description": "Store Word Left: Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word"
    },
    {
      "pattern": "swl $t1,100($t2)",
      "replacement": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "swl RG1, 0($1)"
      ],
      "description": "Store Word Left: Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word"
    },
    {
      "pattern": "swl $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "swl RG1, VL2($1)"
      ],
      "description": "Store Word Left: Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word"
    },
    {
      "pattern": "swl $t1,label",
      "replacement": [
        "lui $1, LH2",
        "swl RG1, LL2($1)",
        "COMPACT",
        "swl RG1, LL2($0)"
      ],
      "description": "Store Word Left: Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word"
    },
    {
      "pattern": "swl $t1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "swl RG1, LL2($1)",
        "COMPACT",
        "swl RG1, LL2(RG4)"
      ],
      "description": "Store Word Left: Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word"
    },
    {
      "pattern": "swl $t1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "swl RG1, LLP($1)"
      ],
      "description": "Store Word Left: Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word"
    },
    {
      "pattern": "swl $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "swl RG1, LLP($1)"
      ],
      "description": "Store Word Left: Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word"
    }
  ],
  "lwr": [
    {
      "pattern": "lwr $t1,($t2)",
      "replacement": [
        "lwr RG1,0(RG3)"
      ],
      "description": "Load Word Right: Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word"
    },
    {
      "pattern": "lwr $t1,-100",
      "replacement": [
        "lwr RG1,VL2($0)"
      ],
      "description": "Load Word Right: Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word"
    },
    {
      "pattern": "lwr $t1,100",
      "replacement": [
        "ori $1, $0, VL2U",
        "lwr RG1, 0($1)"
      ],
      "description": "Load Word Right: Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word"
    },
    {
      "pattern": "lwr $t1,100000",
      "replacement": [
        "lui $1, VH2",
        "lwr RG1,VL2($1)"
      ],
      "description": "Load Word Right: Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word"
    },
    {
      "pattern": "lwr $t1,100($t2)",
      "replacement": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "lwr RG1, 0($1)"
      ],
      "description": "Load Word Right: Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word"
    },
    {
      "pattern": "lwr $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lwr RG1, VL2($1)"
      ],
      "description": "Load Word Right: Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word"
    },
    {
      "pattern": "lwr $t1,label",
      "replacement": [
        "lui $1, LH2",
        "lwr RG1, LL2($1)",
        "COMPACT",
        "lwr RG1, LL2($0)"
      ],
      "description": "Load Word Right: Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word"
    },
    {
      "pattern": "lwr $t1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lwr RG1, LL2($1)",
        "COMPACT",
        "lwr RG1, LL2(RG4)"
      ],
      "description": "Load Word Right: Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word"
    },
    {
      "pattern": "lwr $t1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "lwr RG1, LLP($1)"
      ],
      "description": "Load Word Right: Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word"
    },
    {
      "pattern": "lwr $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lwr RG1, LLP($1)"
      ],
      "description": "Load Word Right: Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word"
    }
  ],
  "swr": [
    {
      "pattern": "swr $t1,($t2)",
      "replacement": [
        "swr RG1,0(RG3)"
      ],
      "description": "Store Word Right: Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address"
    },
    {
      "pattern": "swr $t1,-100",
      "replacement": [
        "swr RG1,VL2($0)"
      ],
      "description": "Store Word Right: Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address"
    },
    {
      "pattern": "swr $t1,100",
      "replacement": [
        "ori $1, $0, VL2U",
        "swr RG1, 0"
      ],
      "description": "Store Word Right: Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address"
    },
    {
      "pattern": "swr $t1,100000",
      "replacement": [
        "lui $1, VH2",
        "swr RG1,VL2($1)"
      ],
      "description": "Store Word Right: Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address"
    },
    {
      "pattern": "swr $t1,100($t2)",
      "replacement": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "swr RG1, 0($1)"
      ],
      "description": "Store Word Right: Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address"
    },
    {
      "pattern": "swr $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "swr RG1, VL2($1)"
      ],
      "description": "Store Word Right: Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address"
    },
    {
      "pattern": "swr $t1,label",
      "replacement": [
        "lui $1, LH2",
        "swr RG1, LL2($1)",
        "COMPACT",
        "swr RG1, LL2($0)"
      ],
      "description": "Store Word Right: Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address"
    },
    {
      "pattern": "swr $t1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "swr RG1, LL2($1)",
        "COMPACT",
        "swr RG1, LL2(RG4)"
      ],
      "description": "Store Word Right: Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address"
    },
    {
      "pattern": "swr $t1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "swr RG1, LLP($1)"
      ],
      "description": "Store Word Right: Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address"
    },
    {
      "pattern": "swr $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "swr RG1, LLP($1)"
      ],
      "description": "Store Word Right: Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address"
    }
  ],
  "ll": [
    {
      "pattern": "ll $t1,($t2)",
      "replacement": [
        "ll RG1,0(RG3)"
      ],
      "description": "Load Linked: Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors."
    },
    {
      "pattern": "ll $t1,-100",
      "replacement": [
        "ll RG1,VL2($0)"
      ],
      "description": "Load Linked: Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors."
    },
    {
      "pattern": "ll $t1,100",
      "replacement": [
        "ori $1, $0, VL2U",
        "ll RG1, 0($1)"
      ],
      "description": "Load Linked: Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors."
    },
    {
      "pattern": "ll $t1,100000",
      "replacement": [
        "lui $1, VH2",
        "ll RG1,VL2($1)"
      ],
      "description": "Load Linked: Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors."
    },
    {
      "pattern": "ll $t1,100($t2)",
      "replacement": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "ll RG1, 0($1)"
      ],
      "description": "Load Linked: Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors."
    },
    {
      "pattern": "ll $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "ll RG1, VL2($1)"
      ],
      "description": "Load Linked: Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors."
    },
    {
      "pattern": "ll $t1,label",
      "replacement": [
        "lui $1, LH2",
        "ll RG1, LL2($1)",
        "COMPACT",
        "ll RG1, LL2($0)"
      ],
      "description": "Load Linked: Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors."
    },
    {
      "pattern": "ll $t1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "ll RG1, LL2($1)",
        "COMPACT",
        "ll RG1, LL2(RG4)"
      ],
      "description": "Load Linked: Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors."
    },
    {
      "pattern": "ll $t1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "ll RG1, LLP($1)"
      ],
      "description": "Load Linked: Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors."
    },
    {
      "pattern": "ll $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "ll RG1, LLP($1)"
      ],
      "description": "Load Linked: Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors."
    }
  ],
  "sc": [
    {
      "pattern": "sc $t1,($t2)",
      "replacement": [
        "sc RG1,0(RG3)"
      ],
      "description": "Store Conditional: Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors."
    },
    {
      "pattern": "sc $t1,-100",
      "replacement": [
        "sc RG1,VL2($0)"
      ],
      "description": "Store Conditional: Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors."
    },
    {
      "pattern": "sc $t1,100",
      "replacement": [
        "ori $1, $0, VL2U",
        "sc RG1, 0($1)"
      ],
      "description": "Store Conditional: Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors."
    },
    {
      "pattern": "sc $t1,100000",
      "replacement": [
        "lui $1, VH2",
        "sc RG1,VL2($1)"
      ],
      "description": "Store Conditional: Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors."
    },
    {
      "pattern": "sc $t1,100($t2)",
      "replacement": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "sc RG1, 0($1)"
      ],
      "description": "Store Conditional: Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors."
    },
    {
      "pattern": "sc $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "sc RG1, VL2($1)"
      ],
      "description": "Store Conditional: Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors."
    },
    {
      "pattern": "sc $t1,label",
      "replacement": [
        "lui $1, LH2",
        "sc RG1, LL2($1)",
        "COMPACT",
        "sc RG1, LL2($0)"
      ],
      "description": "Store Conditional: Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors."
    },
    {
      "pattern": "sc $t1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "sc RG1, LL2($1)",
        "COMPACT",
        "sc RG1, LL2(RG4)"
      ],
      "description": "Store Conditional: Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors."
    },
    {
      "pattern": "sc $t1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "sc RG1, LLP($1)"
      ],
      "description": "Store Conditional: Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors."
    },
    {
      "pattern": "sc $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "sc RG1, LLP($1)"
      ],
      "description": "Store Conditional: Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors."
    }
  ],
  "ulw": [
    {
      "pattern": "ulw $t1,100000",
      "replacement": [
        "lui $1, VH2P3",
        "lwl RG1, VL2P3($1)",
        "lui $1, VH2",
        "lwr RG1, VL2($1)"
      ],
      "description": "Unaligned Load Word: Set $t1 to the 32 bits starting at effective memory byte address"
    },
    {
      "pattern": "ulw $t1,label",
      "replacement": [
        "lui $1, LH2P3",
        "lwl RG1, LL2P3($1)",
        "lui $1, LH2",
        "lwr RG1, LL2($1)"
      ],
      "description": "Unaligned Load Word: Set $t1 to the 32 bits starting at effective memory byte address"
    },
    {
      "pattern": "ulw $t1,label+100000",
      "replacement": [
        "lui $1, LHPAP3",
        "lwl RG1, LLPP3($1)",
        "lui $1, LHPA",
        "lwr RG1, LLP($1)"
      ],
      "description": "Unaligned Load Word: Set $t1 to the 32 bits starting at effective memory byte address"
    },
    {
      "pattern": "ulw $t1,($t2)",
      "replacement": [
        "lwl RG1, 3(RG3)",
        "lwr RG1, 0(RG3)"
      ],
      "description": "Unaligned Load Word: Set $t1 to the 32 bits starting at effective memory byte address"
    },
    {
      "pattern": "ulw $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2P3",
        "addu $1, $1, RG4",
        "lwl RG1, VL2P3($1)",
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lwr RG1, VL2($1)"
      ],
      "description": "Unaligned Load Word: Set $t1 to the 32 bits starting at effective memory byte address"
    },
    {
      "pattern": "ulw $t1,label($t2)",
      "replacement": [
        "lui $1, LH2P3",
        "addu $1, $1, RG4",
        "lwl RG1, LL2P3($1)",
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lwr RG1, LL2($1)"
      ],
      "description": "Unaligned Load Word: Set $t1 to the 32 bits starting at effective memory byte address"
    },
    {
      "pattern": "ulw $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPAP3",
        "addu $1, $1, RG6",
        "lwl RG1, LLPP3($1)",
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lwr RG1, LLP($1)"
      ],
      "description": "Unaligned Load Word: Set $t1 to the 32 bits starting at effective memory byte address"
    }
  ],
  "ulh": [
    {
      "pattern": "ulh $t1,100000",
      "replacement": [
        "lui $1, VH2P1",
        "lb RG1, VL2P1($1)",
        "lui $1, VH2",
        "lbu $1, VL2($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ],
      "description": "Unaligned Load Halfword: Set $t1 to the 16 bits, sign-extended, starting at effective memory byte address"
    },
    {
      "pattern": "ulh $t1,label",
      "replacement": [
        "lui $1, LH2P1",
        "lb RG1, LL2P1($1)",
        "lui $1, LH2",
        "lbu $1, LL2($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ],
      "description": "Unaligned Load Halfword: Set $t1 to the 16 bits, sign-extended, starting at effective memory byte address"
    },
    {
      "pattern": "ulh $t1,label+100000",
      "replacement": [
        "lui $1, LHPAP1",
        "lb RG1, LLPP1($1)",
        "lui $1, LHPA",
        "lbu $1, LLP($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ],
      "description": "Unaligned Load Halfword: Set $t1 to the 16 bits, sign-extended, starting at effective memory byte address"
    },
    {
      "pattern": "ulh $t1,($t2)",
      "replacement": [
        "lb RG1, 1(RG3)",
        "lbu $1, 0(RG3)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1",
        ""
      ],
      "description": "Unaligned Load Halfword: Set $t1 to the 16 bits, sign-extended, starting at effective memory byte address"
    },
    {
      "pattern": "ulh $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2P1",
        "addu $1, $1, RG4",
        "lb RG1, VL2P1($1)",
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lbu $1, VL2($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ],
      "description": "Unaligned Load Halfword: Set $t1 to the 16 bits, sign-extended, starting at effective memory byte address"
    },
    {
      "pattern": "ulh $t1,label($t2)",
      "replacement": [
        "lui $1, LH2P1",
        "addu $1, $1, RG4",
        "lb RG1, LL2P1($1)",
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lbu $1, LL2($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ],
      "description": "Unaligned Load Halfword: Set $t1 to the 16 bits, sign-extended, starting at effective memory byte address"
    },
    {
      "pattern": "ulh $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPAP1",
        "addu $1, $1, RG6",
        "lb RG1, LLPP1($1)",
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lbu $1, LLP($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ],
      "description": "Unaligned Load Halfword: Set $t1 to the 16 bits, sign-extended, starting at effective memory byte address"
    }
  ],
  "ulhu": [
    {
      "pattern": "ulhu $t1,100000",
      "replacement": [
        "lui $1, VH2P1",
        "lbu RG1, VL2P1($1)",
        "lui $1, VH2",
        "lbu $1, VL2($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ],
      "description": "Unaligned Load Halfword: Set $t1 to the 16 bits, zero-extended, starting at effective memory byte address"
    },
    {
      "pattern": "ulhu $t1,label",
      "replacement": [
        "lui $1, LH2P1",
        "lbu RG1, LL2P1($1)",
        "lui $1, LH2",
        "lbu $1, LL2($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ],
      "description": "Unaligned Load Halfword: Set $t1 to the 16 bits, zero-extended, starting at effective memory byte address"
    },
    {
      "pattern": "ulhu $t1,label+100000",
      "replacement": [
        "lui $1, LHPAP1",
        "lbu RG1, LLPP1($1)",
        "lui $1, LHPA",
        "lbu $1, LLP($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ],
      "description": "Unaligned Load Halfword: Set $t1 to the 16 bits, zero-extended, starting at effective memory byte address"
    },
    {
      "pattern": "ulhu $t1,($t2)",
      "replacement": [
        "lbu RG1, 1(RG3)",
        "lbu $1, 0(RG3)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1",
        ""
      ],
      "description": "Unaligned Load Halfword: Set $t1 to the 16 bits, zero-extended, starting at effective memory byte address"
    },
    {
      "pattern": "ulhu $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2P1",
        "addu $1, $1, RG4",
        "lbu RG1, VL2P1($1)",
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lbu $1, VL2($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ],
      "description": "Unaligned Load Halfword: Set $t1 to the 16 bits, zero-extended, starting at effective memory byte address"
    },
    {
      "pattern": "ulhu $t1,label($t2)",
      "replacement": [
        "lui $1, LH2P1",
        "addu $1, $1, RG4",
        "lbu RG1, LL2P1($1)",
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lbu $1, LL2($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ],
      "description": "Unaligned Load Halfword: Set $t1 to the 16 bits, zero-extended, starting at effective memory byte address"
    },
    {
      "pattern": "ulhu $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPAP1",
        "addu $1, $1, RG6",
        "lbu RG1, LLPP1($1)",
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lbu $1, LLP($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ],
      "description": "Unaligned Load Halfword: Set $t1 to the 16 bits, zero-extended, starting at effective memory byte address"
    }
  ],
  "ld": [
    {
      "pattern": "ld $t1,100000",
      "replacement": [
        "lui $1, VH2",
        "lw RG1, VL2($1)",
        "lui $1, VH2P4",
        "lw NR1, VL2P4($1)"
      ],
      "description": "Load Doubleword: Set $t1 and the next register to the 64 bits starting at effective memory word address"
    },
    {
      "pattern": "ld $t1,label",
      "replacement": [
        "lui $1, LH2",
        "lw RG1, LL2($1)",
        "lui $1, LH2P4",
        "lw NR1, LL2P4($1)"
      ],
      "description": "Load Doubleword: Set $t1 and the next register to the 64 bits starting at effective memory word address"
    },
    {
      "pattern": "ld $t1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "lw RG1, LLP($1)",
        "lui $1, LHPAP4",
        "lw NR1, LLPP4($1)"
      ],
      "description": "Load Doubleword: Set $t1 and the next register to the 64 bits starting at effective memory word address"
    },
    {
      "pattern": "ld $t1,($t2)",
      "replacement": [
        "lw RG1, 0(RG3)",
        "lw NR1, 4(RG3)"
      ],
      "description": "Load Doubleword: Set $t1 and the next register to the 64 bits starting at effective memory word address"
    },
    {
      "pattern": "ld $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lw RG1, VL2($1)",
        "lui $1, VH2P4",
        "addu $1, $1, RG4",
        "lw NR1, VL2P4($1)"
      ],
      "description": "Load Doubleword: Set $t1 and the next register to the 64 bits starting at effective memory word address"
    },
    {
      "pattern": "ld $t1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lw RG1, LL2($1)",
        "lui $1, LH2P4",
        "addu $1, $1, RG4",
        "lw NR1, LL2P4($1)"
      ],
      "description": "Load Doubleword: Set $t1 and the next register to the 64 bits starting at effective memory word address"
    },
    {
      "pattern": "ld $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lw RG1, LLP($1)",
        "lui $1, LHPAP4",
        "addu $1, $1, RG6",
        "lw NR1, LLPP4($1)"
      ],
      "description": "Load Doubleword: Set $t1 and the next register to the 64 bits starting at effective memory word address"
    }
  ],
  "usw": [
    {
      "pattern": "usw $t1,100000",
      "replacement": [
        "lui $1, VH2P3",
        "swl RG1, VL2P3($1)",
        "lui $1, VH2",
        "swr RG1, VL2($1)"
      ],
      "description": "Unaligned Store Word: Store $t1 contents into the 32 bits starting at effective memory byte address"
    },
    {
      "pattern": "usw $t1,label",
      "replacement": [
        "lui $1, LH2P3",
        "swl RG1, LL2P3($1)",
        "lui $1, LH2",
        "swr RG1, LL2($1)"
      ],
      "description": "Unaligned Store Word: Store $t1 contents into the 32 bits starting at effective memory byte address"
    },
    {
      "pattern": "usw $t1,label+100000",
      "replacement": [
        "lui $1, LHPAP3",
        "swl RG1, LLPP3($1)",
        "lui $1, LHPA",
        "swr RG1, LLP($1)"
      ],
      "description": "Unaligned Store Word: Store $t1 contents into the 32 bits starting at effective memory byte address"
    },
    {
      "pattern": "usw $t1,($t2)",
      "replacement": [
        "swl RG1, 3(RG3)",
        "swr RG1, 0(RG3)"
      ],
      "description": "Unaligned Store Word: Store $t1 contents into the 32 bits starting at effective memory byte address"
    },
    {
      "pattern": "usw $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2P3",
        "addu $1, $1, RG4",
        "swl RG1, VL2P3($1)",
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "swr RG1, VL2($1)"
      ],
      "description": "Unaligned Store Word: Store $t1 contents into the 32 bits starting at effective memory byte address"
    },
    {
      "pattern": "usw $t1,label($t2)",
      "replacement": [
        "lui $1, LH2P3",
        "addu $1, $1, RG4",
        "swl RG1, LL2P3($1)",
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "swr RG1, LL2($1)"
      ],
      "description": "Unaligned Store Word: Store $t1 contents into the 32 bits starting at effective memory byte address"
    },
    {
      "pattern": "usw $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPAP3",
        "addu $1, $1, RG6",
        "swl RG1, LLPP3($1)",
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "swr RG1, LLP($1)"
      ],
      "description": "Unaligned Store Word: Store $t1 contents into the 32 bits starting at effective memory byte address"
    }
  ],
  "ush": [
    {
      "pattern": "ush $t1,100000",
      "replacement": [
        "lui $1, VH2",
        "sb RG1, VL2($1)",
        "sll $1, RG1, 24",
        "srl RG1, RG1, 8",
        "or RG1, RG1, $1",
        "lui $1, VH2P1",
        "sb RG1, VL2P1($1)",
        "srl $1, RG1, 24",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ],
      "description": "Unaligned Store Halfword: Store low-order halfword $t1 contents into the 16 bits starting at effective memory byte address"
    },
    {
      "pattern": "ush $t1,label",
      "replacement": [
        "lui $1, LH2",
        "sb RG1, LL2($1)",
        "sll $1, RG1, 24",
        "srl RG1, RG1, 8",
        "or RG1, RG1, $1",
        "lui $1, LH2P1",
        "sb RG1, LL2P1($1)",
        "srl $1, RG1, 24",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ],
      "description": "Unaligned Store Halfword: Store low-order halfword $t1 contents into the 16 bits starting at effective memory byte address"
    },
    {
      "pattern": "ush $t1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "sb RG1, LLP($1)",
        "sll $1, RG1, 24",
        "srl RG1, RG1, 8",
        "or RG1, RG1, $1",
        "lui $1, LHPAP1",
        "sb RG1, LLPP1($1)",
        "srl $1, RG1, 24",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ],
      "description": "Unaligned Store Halfword: Store low-order halfword $t1 contents into the 16 bits starting at effective memory byte address"
    },
    {
      "pattern": "ush $t1,($t2)",
      "replacement": [
        "sb RG1, 0(RG3)",
        "sll $1, RG1, 24",
        "srl RG1, RG1, 8",
        "or RG1, RG1, $1",
        "sb RG1, 1(RG3)",
        "srl $1, RG1, 24",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ],
      "description": "Unaligned Store Halfword: Store low-order halfword $t1 contents into the 16 bits starting at effective memory byte address"
    },
    {
      "pattern": "ush $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "sb RG1, VL2($1)",
        "sll $1, RG1, 24",
        "srl RG1, RG1, 8",
        "or RG1, RG1, $1",
        "lui $1, VH2P1",
        "addu $1, $1, RG4",
        "sb RG1, VL2P1($1)",
        "srl $1, RG1, 24",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ],
      "description": "Unaligned Store Halfword: Store low-order halfword $t1 contents into the 16 bits starting at effective memory byte address"
    },
    {
      "pattern": "ush $t1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "sb RG1, LL2($1)",
        "sll $1, RG1, 24",
        "srl RG1, RG1, 8",
        "or RG1, RG1, $1",
        "lui $1, LH2P1",
        "addu $1, $1, RG4",
        "sb RG1, LL2P1($1)",
        "srl $1, RG1, 24",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ],
      "description": "Unaligned Store Halfword: Store low-order halfword $t1 contents into the 16 bits starting at effective memory byte address"
    },
    {
      "pattern": "ush $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "sb RG1, LLP($1)",
        "sll $1, RG1, 24",
        "srl RG1, RG1, 8",
        "or RG1, RG1, $1",
        "lui $1, LHPAP1",
        "addu $1, $1, RG6",
        "sb RG1, LLPP1($1)",
        "srl $1, RG1, 24",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ],
      "description": "Unaligned Store Halfword: Store low-order halfword $t1 contents into the 16 bits starting at effective memory byte address"
    }
  ],
  "sd": [
    {
      "pattern": "sd $t1,100000",
      "replacement": [
        "lui $1, VH2",
        "sw RG1, VL2($1)",
        "lui $1, VH2P4",
        "sw NR1, VL2P4($1)"
      ],
      "description": "Store Doubleword: Store contents of $t1 and the next register to the 64 bits starting at effective memory word address"
    },
    {
      "pattern": "sd $t1,label",
      "replacement": [
        "lui $1, LH2",
        "sw RG1, LL2($1)",
        "lui $1, LH2P4",
        "sw NR1, LL2P4($1)"
      ],
      "description": "Store Doubleword: Store contents of $t1 and the next register to the 64 bits starting at effective memory word address"
    },
    {
      "pattern": "sd $t1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "sw RG1, LLP($1)",
        "lui $1, LHPAP4",
        "sw NR1, LLPP4($1)"
      ],
      "description": "Store Doubleword: Store contents of $t1 and the next register to the 64 bits starting at effective memory word address"
    },
    {
      "pattern": "sd $t1,($t2)",
      "replacement": [
        "sw RG1, 0(RG3)",
        "sw NR1, 4(RG3)"
      ],
      "description": "Store Doubleword: Store contents of $t1 and the next register to the 64 bits starting at effective memory word address"
    },
    {
      "pattern": "sd $t1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "sw RG1, VL2($1)",
        "lui $1, VH2P4",
        "addu $1, $1, RG4",
        "sw NR1, VL2P4($1)"
      ],
      "description": "Store Doubleword: Store contents of $t1 and the next register to the 64 bits starting at effective memory word address"
    },
    {
      "pattern": "sd $t1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "sw RG1, LL2($1)",
        "lui $1, LH2P4",
        "addu $1, $1, RG4",
        "sw NR1, LL2P4($1)"
      ],
      "description": "Store Doubleword: Store contents of $t1 and the next register to the 64 bits starting at effective memory word address"
    },
    {
      "pattern": "sd $t1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "sw RG1, LLP($1)",
        "lui $1, LHPAP4",
        "addu $1, $1, RG6",
        "sw NR1, LLPP4($1)"
      ],
      "description": "Store Doubleword: Store contents of $t1 and the next register to the 64 bits starting at effective memory word address"
    }
  ],
  "lwc1": [
    {
      "pattern": "lwc1 $f1,($t2)",
      "replacement": [
        "lwc1 RG1,0(RG3)"
      ],
      "description": "Load Word Coprocessor 1: Set $f1 to 32-bit value from effective memory word address"
    },
    {
      "pattern": "lwc1 $f1,-100",
      "replacement": [
        "lwc1 RG1,VL2($0)"
      ],
      "description": "Load Word Coprocessor 1: Set $f1 to 32-bit value from effective memory word address"
    },
    {
      "pattern": "lwc1 $f1,100000",
      "replacement": [
        "lui $1, VH2",
        "lwc1 RG1,VL2($1)"
      ],
      "description": "Load Word Coprocessor 1: Set $f1 to 32-bit value from effective memory word address"
    },
    {
      "pattern": "lwc1 $f1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lwc1 RG1, VL2($1)"
      ],
      "description": "Load Word Coprocessor 1: Set $f1 to 32-bit value from effective memory word address"
    },
    {
      "pattern": "lwc1 $f1,label",
      "replacement": [
        "lui $1, LH2",
        "lwc1 RG1, LL2($1)",
        "COMPACT",
        "lwc1 RG1, LL2($0)"
      ],
      "description": "Load Word Coprocessor 1: Set $f1 to 32-bit value from effective memory word address"
    },
    {
      "pattern": "lwc1 $f1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lwc1 RG1, LL2($1)",
        "COMPACT",
        "lwc1 RG1, LL2(RG4)"
      ],
      "description": "Load Word Coprocessor 1: Set $f1 to 32-bit value from effective memory word address"
    },
    {
      "pattern": "lwc1 $f1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "lwc1 RG1, LLP($1)"
      ],
      "description": "Load Word Coprocessor 1: Set $f1 to 32-bit value from effective memory word address"
    },
    {
      "pattern": "lwc1 $f1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lwc1 RG1, LLP($1)"
      ],
      "description": "Load Word Coprocessor 1: Set $f1 to 32-bit value from effective memory word address"
    }
  ],
  "ldc1": [
    {
      "pattern": "ldc1 $f2,($t2)",
      "replacement": [
        "ldc1 RG1,0(RG3)"
      ],
      "description": "Load Doubleword Coprocessor 1: Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address"
    },
    {
      "pattern": "ldc1 $f2,-100",
      "replacement": [
        "ldc1 RG1,VL2($0)"
      ],
      "description": "Load Doubleword Coprocessor 1: Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address"
    },
    {
      "pattern": "ldc1 $f2,100000",
      "replacement": [
        "lui $1, VH2",
        "ldc1 RG1,VL2($1)"
      ],
      "description": "Load Doubleword Coprocessor 1: Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address"
    },
    {
      "pattern": "ldc1 $f2,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "ldc1 RG1, VL2($1)"
      ],
      "description": "Load Doubleword Coprocessor 1: Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address"
    },
    {
      "pattern": "ldc1 $f2,label",
      "replacement": [
        "lui $1, LH2",
        "ldc1 RG1, LL2($1)",
        "COMPACT",
        "ldc1 RG1, LL2($0)"
      ],
      "description": "Load Doubleword Coprocessor 1: Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address"
    },
    {
      "pattern": "ldc1 $f2,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "ldc1 RG1, LL2($1)",
        "COMPACT",
        "ldc1 RG1, LL2(RG4)"
      ],
      "description": "Load Doubleword Coprocessor 1: Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address"
    },
    {
      "pattern": "ldc1 $f2,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "ldc1 RG1, LLP($1)"
      ],
      "description": "Load Doubleword Coprocessor 1: Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address"
    },
    {
      "pattern": "ldc1 $f2,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "ldc1 RG1, LLP($1)"
      ],
      "description": "Load Doubleword Coprocessor 1: Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address"
    }
  ],
  "swc1": [
    {
      "pattern": "swc1 $f1,($t2)",
      "replacement": [
        "swc1 RG1,0(RG3)"
      ],
      "description": "Store Word Coprocessor 1: Store 32-bit value from $f1 to effective memory word address"
    },
    {
      "pattern": "swc1 $f1,-100",
      "replacement": [
        "swc1 RG1,VL2($0)"
      ],
      "description": "Store Word Coprocessor 1: Store 32-bit value from $f1 to effective memory word address"
    },
    {
      "pattern": "swc1 $f1,100000",
      "replacement": [
        "lui $1, VH2",
        "swc1 RG1,VL2($1)"
      ],
      "description": "Store Word Coprocessor 1: Store 32-bit value from $f1 to effective memory word address"
    },
    {
      "pattern": "swc1 $f1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "swc1 RG1, VL2($1)"
      ],
      "description": "Store Word Coprocessor 1: Store 32-bit value from $f1 to effective memory word address"
    },
    {
      "pattern": "swc1 $f1,label",
      "replacement": [
        "lui $1, LH2",
        "swc1 RG1, LL2($1)",
        "COMPACT",
        "swc1 RG1, LL2($0)"
      ],
      "description": "Store Word Coprocessor 1: Store 32-bit value from $f1 to effective memory word address"
    },
    {
      "pattern": "swc1 $f1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "swc1 RG1, LL2($1)",
        "COMPACT",
        "swc1 RG1, LL2(RG4)"
      ],
      "description": "Store Word Coprocessor 1: Store 32-bit value from $f1 to effective memory word address"
    },
    {
      "pattern": "swc1 $f1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "swc1 RG1, LLP($1)"
      ],
      "description": "Store Word Coprocessor 1: Store 32-bit value from $f1 to effective memory word address"
    },
    {
      "pattern": "swc1 $f1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "swc1 RG1, LLP($1)"
      ],
      "description": "Store Word Coprocessor 1: Store 32-bit value from $f1 to effective memory word address"
    }
  ],
  "sdc1": [
    {
      "pattern": "sdc1 $f2,($t2)",
      "replacement": [
        "sdc1 RG1,0(RG3)"
      ],
      "description": "Store Doubleword Coprocessor 1: Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address"
    },
    {
      "pattern": "sdc1 $f2,-100",
      "replacement": [
        "sdc1 RG1,VL2($0)"
      ],
      "description": "Store Doubleword Coprocessor 1: Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address"
    },
    {
      "pattern": "sdc1 $f2,100000",
      "replacement": [
        "lui $1, VH2",
        "sdc1 RG1,VL2($1)"
      ],
      "description": "Store Doubleword Coprocessor 1: Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address"
    },
    {
      "pattern": "sdc1 $f2,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "sdc1 RG1, VL2($1)"
      ],
      "description": "Store Doubleword Coprocessor 1: Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address"
    },
    {
      "pattern": "sdc1 $f2,label",
      "replacement": [
        "lui $1, LH2",
        "sdc1 RG1, LL2($1)",
        "COMPACT",
        "sdc1 RG1, LL2($0)"
      ],
      "description": "Store Doubleword Coprocessor 1: Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address"
    },
    {
      "pattern": "sdc1 $f2,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "sdc1 RG1, LL2($1)",
        "COMPACT",
        "sdc1 RG1, LL2(RG4)"
      ],
      "description": "Store Doubleword Coprocessor 1: Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address"
    },
    {
      "pattern": "sdc1 $f2,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "sdc1 RG1, LLP($1)"
      ],
      "description": "Store Doubleword Coprocessor 1: Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address"
    },
    {
      "pattern": "sdc1 $f2,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "sdc1 RG1, LLP($1)"
      ],
      "description": "Store Doubleword Coprocessor 1: Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address"
    }
  ],
  "l.s": [
    {
      "pattern": "l.s $f1,($t2)",
      "replacement": [
        "lwc1 RG1,0(RG3)"
      ],
      "description": "Load floating point Single precision: Set $f1 to 32-bit value at effective memory word address"
    },
    {
      "pattern": "l.s $f1,-100",
      "replacement": [
        "lwc1 RG1,VL2($0)"
      ],
      "description": "Load floating point Single precision: Set $f1 to 32-bit value at effective memory word address"
    },
    {
      "pattern": "l.s $f1,100000",
      "replacement": [
        "lui $1, VH2",
        "lwc1 RG1,VL2($1)"
      ],
      "description": "Load floating point Single precision: Set $f1 to 32-bit value at effective memory word address"
    },
    {
      "pattern": "l.s $f1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lwc1 RG1, VL2($1)"
      ],
      "description": "Load floating point Single precision: Set $f1 to 32-bit value at effective memory word address"
    },
    {
      "pattern": "l.s $f1,label",
      "replacement": [
        "lui $1, LH2",
        "lwc1 RG1, LL2($1)",
        "COMPACT",
        "lwc1 RG1, LL2($0)"
      ],
      "description": "Load floating point Single precision: Set $f1 to 32-bit value at effective memory word address"
    },
    {
      "pattern": "l.s $f1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lwc1 RG1, LL2($1)",
        "COMPACT",
        "lwc1 RG1, LL2(RG4)"
      ],
      "description": "Load floating point Single precision: Set $f1 to 32-bit value at effective memory word address"
    },
    {
      "pattern": "l.s $f1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "lwc1 RG1, LLP($1)"
      ],
      "description": "Load floating point Single precision: Set $f1 to 32-bit value at effective memory word address"
    },
    {
      "pattern": "l.s $f1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lwc1 RG1, LLP($1)"
      ],
      "description": "Load floating point Single precision: Set $f1 to 32-bit value at effective memory word address"
    }
  ],
  "s.s": [
    {
      "pattern": "s.s $f1,($t2)",
      "replacement": [
        "swc1 RG1,0(RG3)"
      ],
      "description": "Store floating point Single precision: Store 32-bit value from $f1 to effective memory word address"
    },
    {
      "pattern": "s.s $f1,-100",
      "replacement": [
        "swc1 RG1,VL2($0)"
      ],
      "description": "Store floating point Single precision: Store 32-bit value from $f1 to effective memory word address"
    },
    {
      "pattern": "s.s $f1,100000",
      "replacement": [
        "lui $1, VH2",
        "swc1 RG1,VL2($1)"
      ],
      "description": "Store floating point Single precision: Store 32-bit value from $f1 to effective memory word address"
    },
    {
      "pattern": "s.s $f1,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "swc1 RG1, VL2($1)"
      ],
      "description": "Store floating point Single precision: Store 32-bit value from $f1 to effective memory word address"
    },
    {
      "pattern": "s.s $f1,label",
      "replacement": [
        "lui $1, LH2",
        "swc1 RG1, LL2($1)",
        "COMPACT",
        "swc1 RG1, LL2($0)"
      ],
      "description": "Store floating point Single precision: Store 32-bit value from $f1 to effective memory word address"
    },
    {
      "pattern": "s.s $f1,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "swc1 RG1, LL2($1)",
        "COMPACT",
        "swc1 RG1, LL2(RG4)"
      ],
      "description": "Store floating point Single precision: Store 32-bit value from $f1 to effective memory word address"
    },
    {
      "pattern": "s.s $f1,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "swc1 RG1, LLP($1)"
      ],
      "description": "Store floating point Single precision: Store 32-bit value from $f1 to effective memory word address"
    },
    {
      "pattern": "s.s $f1,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "swc1 RG1, LLP($1)"
      ],
      "description": "Store floating point Single precision: Store 32-bit value from $f1 to effective memory word address"
    }
  ],
  "l.d": [
    {
      "pattern": "l.d $f2,($t2)",
      "replacement": [
        "ldc1 RG1,0(RG3)"
      ],
      "description": "Load floating point Double precision: Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address"
    },
    {
      "pattern": "l.d $f2,-100",
      "replacement": [
        "ldc1 RG1,VL2($0)"
      ],
      "description": "Load floating point Double precision: Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address"
    },
    {
      "pattern": "l.d $f2,100000",
      "replacement": [
        "lui $1, VH2",
        "ldc1 RG1,VL2($1)"
      ],
      "description": "Load floating point Double precision: Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address"
    },
    {
      "pattern": "l.d $f2,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "ldc1 RG1, VL2($1)"
      ],
      "description": "Load floating point Double precision: Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address"
    },
    {
      "pattern": "l.d $f2,label",
      "replacement": [
        "lui $1, LH2",
        "ldc1 RG1, LL2($1)",
        "COMPACT",
        "ldc1 RG1, LL2($0)"
      ],
      "description": "Load floating point Double precision: Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address"
    },
    {
      "pattern": "l.d $f2,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "ldc1 RG1, LL2($1)",
        "COMPACT",
        "ldc1 RG1, LL2(RG4)"
      ],
      "description": "Load floating point Double precision: Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address"
    },
    {
      "pattern": "l.d $f2,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "ldc1 RG1, LLP($1)"
      ],
      "description": "Load floating point Double precision: Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address"
    },
    {
      "pattern": "l.d $f2,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "ldc1 RG1, LLP($1)"
      ],
      "description": "Load floating point Double precision: Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address"
    }
  ],
  "s.d": [
    {
      "pattern": "s.d $f2,($t2)",
      "replacement": [
        "sdc1 RG1,0(RG3)"
      ],
      "description": "Store floating point Double precision: Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address"
    },
    {
      "pattern": "s.d $f2,-100",
      "replacement": [
        "sdc1 RG1,VL2($0)"
      ],
      "description": "Store floating point Double precision: Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address"
    },
    {
      "pattern": "s.d $f2,100000",
      "replacement": [
        "lui $1, VH2",
        "sdc1 RG1,VL2($1)"
      ],
      "description": "Store floating point Double precision: Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address"
    },
    {
      "pattern": "s.d $f2,100000($t2)",
      "replacement": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "sdc1 RG1, VL2($1)"
      ],
      "description": "Store floating point Double precision: Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address"
    },
    {
      "pattern": "s.d $f2,label",
      "replacement": [
        "lui $1, LH2",
        "sdc1 RG1, LL2($1)",
        "COMPACT",
        "sdc1 RG1, LL2($0)"
      ],
      "description": "Store floating point Double precision: Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address"
    },
    {
      "pattern": "s.d $f2,label($t2)",
      "replacement": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "sdc1 RG1, LL2($1)",
        "COMPACT",
        "sdc1 RG1, LL2(RG4)"
      ],
      "description": "Store floating point Double precision: Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address"
    },
    {
      "pattern": "s.d $f2,label+100000",
      "replacement": [
        "lui $1, LHPA",
        "sdc1 RG1, LLP($1)"
      ],
      "description": "Store floating point Double precision: Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address"
    },
    {
      "pattern": "s.d $f2,label+100000($t2)",
      "replacement": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "sdc1 RG1, LLP($1)"
      ],
      "description": "Store floating point Double precision: Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address"
    }
  ]
}
